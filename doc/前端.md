+ npm安装

[浅析package.json中的devdependencies 和 dependencies_只如初见0706的博客-CSDN博客_devdependencies](https://blog.csdn.net/zrcj0706/article/details/79178371)



# puzzle

+ `.prettierrc.json`设置

因为经常格式报错

使用配置`.prettierrc.json`，使用这个配置在初始话的时候要配置vue

~~~
{
    "singleQuote": false,  
    "semi": true,
    "trailingComma": "all"
}
~~~

+ 本地文件创建

![image-20211213171503583](E:\Document\Typora\img\image-20211213171503583.png)

~~~
iview   # github上好的项目
my-app	# 对应极客时间的demo
vue-alg-analyze	# 要开发的内容
vue-next	# 对应实验楼的读源码的项目
vue-view-screen	# 对应实验楼可视化项目搭建
~~~

+ `npm run lint --fix`查看编译报错

+ 安装elementUI

vue3引入element-ui `npm install element-plus --save`

+ 版本安装过高报错，处理步骤

进入packing.json,降低版本；npm install重新安装,npm run dev重启

+ 卸载某个依赖

~~~
npm uninstall XXX -S // 卸载XXX依赖
~~~

+ 新的vue项目启动

`npm install`

`npm run build`



## 安装报错

[npm使用问题汇总_lonelymanontheway的博客-CSDN博客](https://blog.csdn.net/lonelymanontheway/article/details/88573901)

1. 清理代理和缓存

~~~
npm config set proxy false
npm cache clean
~~~

报错改为

~~~
npm cache clean --force
~~~

2. 依赖添加版本号

 输入npm info xxxx(插件名称) versions可查看当前插件所有版本

~~~
npm info vuex versions
~~~

`dependencies`添加对应库的版本号

3. 换成淘宝镜像

~~~
npm install -g cnpm --registry=https://registry.npm.taobao.org
~~~



## 安装命令

+ 安装vue-video

~~~
npm install vue-video-player --save
~~~

使用cnpm安装

~~~
cnpm install vue-video-player --save
~~~

+ 安装elementUI

~~~
npm install element-plus --save
~~~

+ 安装axios

~~~
npm install axios --save
~~~

+ 安装vuex

~~~
npm install vuex --save
~~~

+ 安装js-cookie

~~~
npm install js-cookie --save
~~~

+ 安装stylus-loader

+ 安装webpack

~~~
 npm install webpack-dev-server --save-dev
~~~



## 服务器搭建相关

+ 查看端口占用

`Netstat –ano|findstr “<端口号>”`





# Vue

## 常见前端标签

~~~
<div> 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化
~~~

+ ul和li用于显示列表

**ul和li列表是使用CSS布局页面时常用的元素。在CSS中，有专门控制列表表现的属性，常用的有list-style-type属性、list-style-image属性、list-style-position属性和list-style属性。**





## vue基础使用

引入方式

1. 直接下载并用 `<script>` 标签引入，`Vue` 会被注册为一个全局变量。

~~~
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
~~~

2. 命令行工具（CLI）

Vue 提供了一个[官方的 CLI](https://github.com/vuejs/vue-cli)，为单页面应用 (SPA) 快速搭建繁杂的脚手架。



### 一个实例

每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：

~~~
var vm = new Vue({
  // 选项
})
~~~



+ el

![img](https://upload-images.jianshu.io/upload_images/5627750-bf6e2ee4561707c5.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 基础示例

Vue 实例选项中的 el、data、methods 这三个属性。

#### 带v-的指令

指令 (Directives) 是带有 `v-` 前缀的特殊特性。

`v-` 是 Vue.js 中特定的标志，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为时，`v-` 前缀很有帮助，但是频繁使用到，也会让人感觉不到代码的简洁之道，就会感到不是太人性化。

同时，在构建由 Vue 管理所有模板的单页面应用程序时，`v-` 前缀也变得没那么重要了。因此，Vue 为 `v-bind` 和 `v-on` 这两个最常用的指令，提供了特定简写：

`v-bind` 绑定属性

```html
<a v-bind:href="url">实验楼</a>
```

我们可以简写为：

```html
<a :href="url">实验楼</a>
```

同样的使用 `v-bind` 绑定的其他属性也可以简写：

```html
v-bind:class="className" 简写为 :class="className" v-bind:value="myValue" 简写为
:value
```

上面 `v-bind` 指令提供简写，同样 `v-on` 指令也提供简写，但是与 `v-bind` 有一些差异，`v-on:` 使用 @ 简写。

```html
<!-- 完整语法 -->
<button v-on:click="handleClick">点我</button>
<!-- 缩写 -->
<button @click="handleClick">点我</button>
```

~~~
v-html  用于渲染
v-bind  用于Txet值改变
v-on:click	按钮
~~~

#### el

1. 基础代码1

~~~
<html>
<head>
    <style>

    </style>
</head>
<body>
    <div id="app">
      {{msg}}
      </div>
        <input type = "text">
        <button>添加</button>
      </div>
    <ul>
        <li>1</li>
    </ul>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
  <script>
      new Vue({
          el: '#app',
          data(){
              return {
                  msg:"hello geektime"
              }
          }
      })
  </script>
</body>
</html>
~~~

+  el 为实例挂载点，上面表示挂载在 id 为 app 的 dom 元素中。data 选项为数据选项，存放绑定数据。除了这两个之外还有实例选项，methods（实例方法）、computed（计算属性） 等，后面我们会学习到。

展示结果

![image-20211202111632523](E:\Document\Typora\img\image-20211202111632523.png)

+ 2.基础代码2

~~~
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>syl-vue</title>
    <!-- 通过cdn方式引入 vue.js -->
    <script src="https://labfile.oss.aliyuncs.com/courses/1262/vue.min.js"></script>
  </head>
  <body>
    <!-- 数据双向绑定 -->
    <div id="app">
      <input type="text" v-model="msg" />
      <p>{{msg}}</p>
    </div>
    <script>
      var app = new Vue({
        el: '#app', //el: 挂载点

        data: {
          //data:数据选项

          msg: 'hello',
        },
      });
    </script>
  </body>
</html>
~~~

**双大括号中的 {{msg}}，绑定至底层 Vue 实例的数据，在浏览器中就被渲染成实例 data 选项中 msg 的值。**



在 Vue.js 中数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：

```html
<div id="app">msg：{{msg}}</div>
```

双大括号中的值将会被替代为对应 data 对象上 `msg` 属性的值。无论何时，绑定的数据对象上 `msg` 属性发生了改变，插值处的内容都会更新。

#### v-once

但是通过使用 `v-once` 指令你也能执行一次性地插值，当数据 **改变时**，插值处的内容 **不会更新**。但是你需要注意一下，该元素节点下面其他数据的绑定，数据改变，内容也不会更新，所以，注意代码块的划分。

```html
<p v-once>msg：{{msg}}</p>
```



一， v-model 是什么 v-model 就是 vue 的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性，也会在更新data绑定属性时候，更新页面上输入控件的值。 二，为什么使用 v-model v-model 作为双**向绑定指令也是 vue 两大核心功能之一，使用非常方便，提高前端开发效率。**



只渲染元素和组件一次，随后的渲染，使用了此指令的元素/组件及其所有的子节点，都会当作静态内容并跳过，这可以用于优化更新性能。



+ 原始HTML

双大括号表达式会将数据解释为普通文本，即使你的数据为 HTML 元素，也不会渲染成对应的标签元素，只能渲染成普通文本，而非 HTML 代码，例子：

~~~
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>syl-vue</title>
    <!-- 通过cdn方式引入 vue.js -->
    <script src="https://labfile.oss.aliyuncs.com/courses/1262/vue.min.js"></script>
  </head>
  <body>
    <!-- 数据绑定 -->
    <div id="app">
      <p>{{msg}}</p>
    </div>
    <script>
      var app = new Vue({
        el: '#app', //el: 挂载点
        data: {
          //data:数据选项
          msg: '<h1>hello syl</h1>',
        },
      });
    </script>
  </body>
</html>
~~~

双大括号表达式会将数据解释为普通文本，如果需要渲染标签。

把`<p>{{msg}}</p>`改为`<div id="app" v-html="msg"></div>`

#### v-bind

在开发的时候，有时候我们的属性不是写死的，有可能是根据我们的一些数据动态地决定的，比如图片标签（<img>）的src属性，我们可能从后端请求了一个包含图片地址的数组，需要将地址动态的绑定到src上面，这时就不能简单的将src写死。还有一个例子就是a标签的href属性。这时可以使用v-bind指令：

　　作用：动态绑定属性；

　　缩写（语法糖）：: (只用一个冒号代替)；

　　预期：

　　　　（1）any (with argument)，任意参数；

　　　　（2）Object (without argument)，对象 。

　　参数：attrOrProp (optional)

所以v-bind:href 可以缩写为 **:href** 

v-bind:href可以缩写为`:class`

双大括号语法不能作用在 HTML 特性（标签属性）上，需要对标签属性操作，应该使用 `v-bind` 指令：

```html
<div v-bind:class="syl-vue-course"></div>
```

v-bind:属性名="name"

比如：

~~~
    <div id="app">
        <a v-bind:href="url">实验楼</a>
      </div>
      <script>
        var app = new Vue({
          el: '#app',
          data: {
            url: 'https://www.lanqiao.cn',
          },
        });
      </script>
~~~

实验楼三个字绑定网址`https://www.lanqiao.cn`

`href`就是网页特性



#### v-on:click

~~~
    <div id="app">
        <p> 我是：{{name}}</p>>
        <input type = "text" v-model = "info">
        <button v-on:click="handleClick">点我</button>
        <a v-bind:href="url">实验楼</a>
      </div>
      <script>
        var app = new Vue({
          el: '#app',
          data: {
            name: '实验楼',
            url: 'https://www.lanqiao.cn',
          },
        methods: {
          //实例方法对象
          handleClick: function () {
            this.name = this.name.split('').reverse().join('');
          },
        },
        });
      </script>
~~~

动态事件

~~~
    <div id="app">
        <p>我叫：{{name}}</p>
        <button v-on:[event]="handleClick">点我</button>
      </div>
      <script>
        var app = new Vue({
          el: '#app',
          data: {
            name: '实验楼',
            event: 'click',
          },
          methods: {
            handleClick: function () {
              this.name = this.name.split('').reverse().join('');
            },
          },
        });
      </script>
~~~



### 修饰符

修饰符是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，大致分为三类，后面课程我们会一一接触到：

- 事件修饰符
- 按键修饰符
- 系统修饰符

~~~
    <div id="app">
        <form action="/" v-on:submit="submit">
          <button type="submit">提交</button>
        </form>
      </div>
      <script>
        var app = new Vue({
          el: '#app',
          data: {},
          methods: {
            submit: function () {
              console.log('成功提交！');
            },
          },
        });
      </script>
~~~

点击发生默认跳转

将`v-on:submit="submit"`改为`v-on:submit.prevent="submit"`，阻止默认跳转



## elment-ui

### el-form

定义列表，包含的单个表为<el-form-item>

+ 属性设置<el-form :inline=

![image-20220613141220736](E:\Document\Typora\img\image-20220613141220736.png)

+ 加上inline之后会在一行

![image-20220613141240078](E:\Document\Typora\img\image-20220613141240078.png)

### el-table

让文件内容居中` :cell-style="{textAlign: 'center'}"`

~~~
<el-table
  :show-header="false"
  :data="tableData"
  :span-method="objectSpanMethod"
  border
  :cell-style="{textAlign: 'center'}"
  style="width: 30%; margin-top: 20px"
>
~~~



## css

+ border-bottom 为div下增加一条横线，如`border-bottom: 2px solid #ccc;`设置颜色和粗度
+ 

# 本地安装

[Windows之vue-cli安装和vue项目快速搭建_zhangxy-CSDN博客_安装vue-cli](https://blog.csdn.net/qq_37682202/article/details/87371296)

# 实验楼：Vue.js和element UI开发管理后台

+ 参考vue3的代码，相关资料

  [Vue3 Composition Admin - 🎉 基于vue3 的管理端模板(Vue3 TS Vuex4 element-plus vue-i18n-next composition-api) vue3-admin vue3-ts-admin - (vue3-composition-admin) (opensourcelibs.com)](https://opensourcelibs.com/lib/vue3-composition-admin)

  [vue3后台管理系统_星宇大前端的博客-CSDN博客](https://blog.csdn.net/zy_flyway/category_6335128.html)

  

## Vue 2和Vue 3的区别

### main.js

+ vue2

~~~
new Vue({
  el: '#app',
  router,
  store,
  render: h => h(App)
})
~~~

或者

~~~
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app")
~~~

+ vue3

~~~
createApp(App).use(router).use(ElementUI).mount("#app")
~~~

### computed

+ vue2

~~~
    computed: {
      username() {
          // 从本地存储中获取值
          let username = localStorage.getItem('ms_username');
          // 对获取到的值进行判断，如果从本地存储能够获取到值，则使用该值，如果不能获取到，则使用 data 中设置的值
          return username ? username : this.name;
      }
    },
~~~

+ vue3

~~~
  setup() {
    const sidebar = computed(() => {
      return store.state.app.sidebar
    })
~~~

### 通讯

`$emit`传输出去，`$on`用于接收

![image-20220523150401549](E:\Document\Typora\img\image-20220523150401549.png)

![image-20220523150258395](E:\Document\Typora\img\image-20220523150258395.png)

用于通讯的bus引入   `import bus from '../../utils/bus';`bus.vue如下所示。

![image-20220523150419815](E:\Document\Typora\img\image-20220523150419815.png)

### 界面引入

+ vue2 大写对应-进行一一引入

![image-20220523154726326](E:\Document\Typora\img\image-20220523154726326.png)

+ vue3

![image-20220523154853197](E:\Document\Typora\img\image-20220523154853197.png)

整体布局格式通过后面的style设定。

### 首页之前先登录的路由配置

我们都知道，想要进入系统首页那肯定是需要进行登录的。所以在创建好登录和首页界面之后，我们就需要对其进行路由配置以实现我们要求的效果。

在 `./router/index.js` 中输入以下代码：

```javascript
import Vue from 'vue';
import Router from 'vue-router';

Vue.use(Router);

export default new Router({
  routes: [
    {
      path: '/',
      //设置重定向，将 Dashboard 组件设为默认路由组件
      redirect: '/dashboard',
    },
    {
      path: '/',
      component: () => import('../components/common/Home.vue'),
      meta: { title: '自述' },
      children: [
        {
          //此时的系统首页是嵌套在 Home 组件当中的
          path: '/dashboard',
          component: () => import('../components/page/Dashboard.vue'),
          meta: { title: '系统首页' },
        },
      ],
    },
    {
      path: '/login',
      component: () => import('../components/page/Login.vue'),
    },
  ],
});
```

这样便可以对这两个页面进行访问。但是又有一个新的问题：因为我们是将 Dashboard 首页组件设置为默认路由组件的，所以项目一运行就会自动跳转到 Dashboard 首页组件。并没有实现我们期望中的先进行登录之后再跳转到首页组件去的效果。

我们要想实现这个效果就需要引入一个新的概念：路由的导航守卫。它的作用便是通过跳转或取消的方式守卫导航。所以我们可以通过 `router.beforeEach` 来注册一个全局前置守卫，对路由的跳转进行一些设置。

在 `src/main.js` 中输入以下代码：

```javascript
import Vue from 'vue';
import App from './App.vue';
import router from './router';
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI, {
  size: 'small',
});

Vue.config.productionTip = false;

//设置全局前置守卫
//这个守卫方法会接受三个参数：
// to：Route ：即将要去往的路由对象，通过这个参数来设置路由的去处。
// from：Route ：当前导航正要离开的路由，通过这个参数来设置路由的出发处。
// next：Function ：这个方法是必须要进行调用的，通过这个参数来resolve这个钩子函数
// next（）：进行下一个钩子，也就是下一个应该去跳转的路由
// next(false)：中断当前导航。
// next('/')：跳转到一个不同的地址，当前导航中断，进行新的导航
// next(error)：终止该导航，并将错误传递给router.onError（）注册的回调。

router.beforeEach((to, from, next) => {
  //对页面的标题进行设置，获取路由元信息当中的title
  document.title = `${to.meta.title} | vue-manage-system`;
  //获取本地存储的用户名
  const role = localStorage.getItem('ms_username');
  //判断是否存在用户名以及下一个钩子是否是跳转到 '/login'
  if (!role && to.path !== '/login') {
    //跳转到 '/login'
    next('/login');
  } else {
    next();
  }
});

new Vue({
  router,
  render: (h) => h(App),
}).$mount('#app');
```

此时，我们运行该项目就会发现，虽然我们默认的页面是系统首页。但是在第一次进入时我们会因为没有登录而跳转到登录界面，经过登录之后才会跳转回系统首页。



## router

可以把路由从

~~~
import vChild from "../components/page/Children.vue";
    {
      path: "/home",
      component: vHome,
      children: [
        {
          // 要注意，以 / 开头的嵌套路径会被当作根路径。 使用嵌套组件无须设置嵌套的路径。
          path: "child",
          component: vChild,
        },
      ],
    },
~~~

改为

~~~
  routes: [
    {
      path: "/home",
      component: () => import("../components/common/Home.vue"),
      children: [
        {
          path: "child",
          component: () => import("../components/page/Children.vue"),
        },
    }
]
~~~

### vue router4使用

[vue3全家桶 之 Vue Router4的使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7031822082329542664)

[vue-router 4 版本学习笔记 - 掘金 (juejin.cn)](https://juejin.cn/post/6994747097899597860)



## element-plus

[组件 | Element](https://element.eleme.cn/#/zh-CN/component/menu)

vue3中弃用slot使用v-slot替代，element-plus代替element-ui

[如何在vue3.0项目中集成Element-plus_卖菜的小白的博客-CSDN博客_element vue3.0](https://blog.csdn.net/weixin_47450807/article/details/123262703)

分为全局引用和部分引用



## element-ui搭建组件模块

接下来我们开始完善第一个公共组件——Header 组件。

![图片描述](https://doc.shiyanlou.com/courses/uid1133717-20190923-1569221301923)

根据项目展示，它可以被拆分为以下几个部分：侧边栏折叠按钮、系统 logo、全屏显示按钮、消息中心、用户头像以及用户名下拉菜单。

在 `src/components/common` 目录下创建 Header.vue 文件。在创建组件的时候，我们应该注意一点：有且只能有一个根节点。所以我们将整个组件包裹在一个 div 中。

```html
<template>
  <div class="header"></div>
</template>
```

#### 创建侧边栏折叠按钮

折叠按钮具有两种状态一种是折叠侧边栏，另一种是展开侧边栏。我们需要给侧边栏设置一个状态标记，用以控制折叠按钮的状态。通过 v-if 和 v-else 来判定折叠按钮的状态。在 Element UI 图标库中找到对应的图标设置样式：

```html
<!-- 折叠按钮 -->
<div class="collapse-btn" @click="collapseChage">
  <!-- 通过 v-if 和 v-else 来判定折叠按钮的状态 -->
  <i v-if="!collapse" class="el-icon-s-fold"></i>
  <i v-else class="el-icon-s-unfold"></i>
</div>
```

#### 创建系统 logo

```html
<!-- 系统 logo -->
<div class="logo">后台管理系统</div>
```

#### 创建右边功能区的第一个功能——全屏按钮

使用 el-tooltip 文字提示功能，通过 effect 来设置 el-tooltip 的主题样式，tooltip 提供了两个主题：dark 和 light。再通过三元表达式来对全屏状态进行判定，从而显示不同的提示信息。

el-tooltip：文字提示功能。

- effect：设置 el-tooltip 的主题样式，tooltip 提供了两个主题：dark 和 light。
- content：设置提示的文字，通过三元表达式来设置不同的文字提示。
- placement：设置文字提示出现的位置。

```html
<!-- 全屏显示 -->
<div class="btn-fullscreen" @click="handleFullScreen">
  <!--tooltip 提供了两个主题：dark 和 light，通过 effect 设置主题 -->
  <!-- 通过三元表达式来设置不同的文字提示，placement 属性控制文字提示出现的位置 -->
  <el-tooltip
    effect="dark"
    :content="fullscreen?`取消全屏`:`全屏`"
    placement="bottom"
  >
    <i class="el-icon-rank"></i>
  </el-tooltip>
</div>
```

#### 创建右边功能区的第二个功能——消息中心

与全屏显示一样，使用 el-tooltip 设置提示文字。同时我们将消息中心设置为一个路由跳转按钮，通过点击可以将路由跳转到 `/tabs`。由 `<router-link>` 实现。 `<router-link>` 组件通过 to 属性来指定需要跳转到的地址。在浏览器中会默认渲染为带有正确链接的 `<a>` 标签。

router-link：在具有路由功能的应用中实现点击导航功能。

- to：指定需要跳转到的地址。

```html
<!-- 消息中心 -->
<div class="btn-bell">
  <el-tooltip
    effect="dark"
    :content="message?`有${message}条未读消息`:`消息中心`"
    placement="bottom"
  >
    <!-- 点击后路由跳转 -->
    <router-link to="/tabs">
      <i class="el-icon-bell"></i>
    </router-link>
  </el-tooltip>
  <!-- 通过对 message 的判定，来决定是否显示小红点 -->
  <span class="btn-bell-badge" v-if="message"></span>
</div>
```

#### 创建右边功能区的第三个功能——用户头像

导入对应用户头像时，要注意导入路径。

```html
<!-- 用户头像 -->
<div class="user-avator">
  <img src="../../assets/img/img.jpg" />
</div>
```

#### 创建右边功能区的第四个功能——用户名下拉菜单

将用户名设置为一个下拉菜单：通过 el-dropdown 实现。通过 trigger 设置触发下拉的行为；command 设置点击菜单项触发的事件回调。下拉列表则是 el-dropdown-menu，将属性 slot 设置为 dropdown 来设置下拉菜单。

```html
<!-- 用户名下拉菜单：trigger 属性配置 click 激活，command：点击菜单项触发的事件回调 -->
<el-dropdown class="user-name" trigger="click" @command="handleCommand">
  <span class="el-dropdown-link">
    {{username}}
    <i class="el-icon-caret-bottom"></i>
  </span>
  <!-- slot 设置下拉列表 -->
  <el-dropdown-menu slot="dropdown">
    <a href="https://github.com/lin-xin/vue-manage-system" target="_blank">
      <el-dropdown-item>项目仓库</el-dropdown-item>
    </a>
    <el-dropdown-item divided command="loginout">退出登录</el-dropdown-item>
  </el-dropdown-menu>
</el-dropdown>
```



## 完善登录与首页组件

### layout

接下来我们就开始对首页组件进行一个完善：

![图片描述](https://doc.shiyanlou.com/courses/uid1133717-20190920-1568960059301)

根据项目展示可以看出，首页组件是嵌套在公共组件 Home 组件当中的。同样的我们可以将首页组件来进行拆分。但是在拆分之前，我们先来了解一个新的知识点：layout 布局。layout 布局是 Element UI 当中的一个流式布局方法，将页面使用 row 和 col 进行划分。一个 el-row 容器被划分为 24 份，el-col 通过对不同的内容设置对应的 el-col 份额来实现流式布局。

所以根据页面我们可以先分为上下两部分：

![图片描述](https://doc.shiyanlou.com/courses/uid1133717-20190924-1569306169329)

每一部分便是一个 el-row 容器，我们先对第一部分做拆分，可以分为左右两部分：

![图片描述](https://doc.shiyanlou.com/courses/uid1133717-20190924-1569306189392)

这便是将第一个 el-row 容器划分为 24 份，使用 el-col 使其中左边部分占据 8 份，右边部分占据 16 份。接下来我们再对左边部分进行拆分，又可以分为上下两部分：

![图片描述](https://doc.shiyanlou.com/courses/uid1133717-20190924-1569306423221)

每一个部分都是一个 el-row 容器。这就是 layout 布局模式，我们可以在 el-row 容器中划分 el-col 容器，又可以在 el-col 容器中继续划分 el-row 容器。如此不断拆分，我们就能够将整个页面划分为成比例的一堆小部分，这样就可以根据窗口的大小动态的进行调整页面的布局。

el-row：行布局容器

- gutter 属性：设置栅格间隔距离。

el-col：列布局容器，Element UI 将一个 el-row 容器分为 24 份，通过 el-col 来进行布局。

- span 属性：表示占据的列数的份额

我们所拆分出来的小部分就可以用代码表示出来：

```html
<template>
    <!-- 首页组件 -->
    <div>
        <!-- 第一部分 -->
        <el-row :gutter="20">
            <!-- 第 1 部分 -->
            <el-col :span="8">
                <!-- 第（1）部分 -->
                <el-card></el-card>

                <!-- 第（2）部分 -->
                <el-card></el-card>
            </el-col>


            <!-- 第 2 部分 -->
            <el-col :span="16">
                <!-- 第 （1）部分 -->
                <el-row :gutter="20"></el-col>
                    <!-- 第 ① 部分 -->
                    <el-col :span="8"></el-col>

                    <!-- 第 ② 部分 -->
                    <el-col :span="8"></el-col>

                    <!-- 第 ③ 部分 -->
                    <el-col :span="8"></el-col>
                </el-row>
                <!-- 第（2）部分 -->
                <el-card></el-card>
            </el-col>
        </el-row>

        <!-- 第二部分 -->
        <el-row :gutter="20">
            <!-- 第 1 部分 -->
            <el-col :span="12">
                <el-card></el-card>
            </el-col>

            <!-- 第 2 部分 -->
            <el-col :span="12">
                <el-card></el-card>
            </el-col>
        </el-row>
    </div>
</template>
```

接下来就开始对这些划分好的小部分进行创建：

### 创建用户登录信息卡片

在 `components/page` 目录下创建 `Dashboard.vue`，我们先创建第一部分中的第 1 部分——用户登录信息卡片。这一部分是第一个 el-row 容器中的第一个 el-col 容器，占据了这个 el-row 容器的 8 份。我们通过 el-col 中 span 属性来表示占据的份额。

el-card：卡片布局容器。Card 组件包括 header 和 body 部分，header 部分需要有显式具名 slot 分发，同时也是可选的。

- shadow 属性：设置阴影显示时机。

el-progress：进度条。

- percentage 属性：设置进度的百分比。

```html
<el-col :span="8">
  <!-- 用户登录信息卡片栏 -->
  <el-card shadow="hover" class="mgb20" style="height:252px;">
    <div class="user-info">
      <!-- 用户头像 -->
      <img src="../../assets/img/img.jpg" class="user-avator" alt="" />
      <div class="user-info-cont">
        <!-- 用户名 -->
        <div class="user-info-name">{{name}}</div>
        <!-- 用户身份 -->
        <div>{{role}}</div>
      </div>
    </div>
    <div class="user-info-list">上次登录时间：<span>2018-01-01</span></div>
    <div class="user-info-list">上次登录地点：<span>东莞</span></div>
  </el-card>
  <!-- 。 -->

  <!-- 编程语言卡片 -->
  <el-card shadow="hover" style="height:252px;">
    <div slot="header" class="clearfix">
      <span>语言详情</span>
    </div>
    Vue
    <!-- 进度条 percentage：进度百分比 -->
    <el-progress :percentage="71.3" color="#42b983"></el-progress>
    JavaScript
    <el-progress :percentage="24.1" color="#f1e05a"></el-progress>
    CSS
    <el-progress :percentage="3.7"></el-progress>
    HTML
    <el-progress :percentage="0.9" color="#f56c6c"></el-progress>
  </el-card>
</el-col>
```



### 创建待办事项卡片

待办事项卡片是业务信息卡片的下部分，即 el-card 容器。

el-table：Table 表格，用于展示多条结构类的数据。

- :data 属性：绑定 data 对象。
- el-table-column：当绑定 data 对象后，用 prop 属性来对应对象中的键名即可填入数据，用 label 属性来定义表格的列名。可以使用 width 属性来定义列宽。

template：组件内容模板。

- slot-scope：作用域插槽，已经废弃。现在使用 v-slot 代替，用于将对象里面的值取出来放置在插槽位置。

```html
<!-- 待办事项卡片 -->
<el-card shadow="hover" style="height:403px;">
  <div slot="header" class="clearfix">
    <span>待办事项</span>
    <el-button style="float: right; padding: 3px 0" type="text">添加</el-button>
  </div>
  <el-table
    :data="todoList"
    :show-header="false"
    height="304"
    style="width: 100%;font-size:14px;"
  >
    <el-table-column width="40">
      <!--  <template slot-scope="scope"> -->
      <template v-slot="scope">
        <!-- 这个插槽设置复选框的初始状态 -->
        <el-checkbox v-model="scope.row.status"></el-checkbox>
      </template>
    </el-table-column>
    <el-table-column>
      <template v-slot="scope">
        <!-- 这个插槽放置data中的title属性值 -->
        <div class="todo-item" :class="{'todo-item-del': scope.row.status}">
          {{scope.row.title}}
        </div>
      </template>
    </el-table-column>
    <el-table-column width="60">
      <template v-slot="scope">
        <i class="el-icon-edit"></i>
        <i class="el-icon-delete"></i>
      </template>
    </el-table-column>
  </el-table>
</el-card>
```





### schart图表

接下来我们创建第二部分——图表卡片，这个 el-row 容器被分为两个 el-col 容器。这两个 el-col 容器各占据 12 份，用于创建两个图表。图表的完成需要使用到 vue-schart 这个封装了 sChart.js 图表库的组件。所以我们要先将其进行引入：

```javascript
import Schart from 'vue-schart';
```

引入之后我们就可以开始创建图表了：

schart：

- canvasId：canvas 标签的 id，必填。
- type：图表类型，必填，可选为：bar（柱形图）、line（折线图）、pie（饼状图）、ring（环形图）。
- options：图表配置参数，可选。
- data：要生成图表的数据，格式为：

```javascript
data: [{ name: 'xx', value: 'yy' }];
```

name 为坐标值，value 为数据值。

### 首页js部分

引入 bus 实现组件之间通信，传递数据。

```javascript
import bus from '../../utils/bus';
```

引入 vue-schart 图表库组件，并挂载到模板上。

```javascript
import Schart from 'vue-schart';
export default {
  components: {
    Schart,
  },
};
```

包含了组件当中需要使用的数据，包括用户名、待办事项卡片中的模拟数据、图表公用的模拟数据以及各图表的不同配置。

```javascript
    data() {
        return {
            // 从本地存储获取用户名
            name: localStorage.getItem('ms_username'),
            // 待办事项卡片模拟数据
            todoList: [{
                    title: '今天要修复100个bug',
                    status: false,
                },
                {
                    title: '今天要修复100个bug',
                    status: false,
                },
                {
                    title: '今天要写100行代码加几个bug吧',
                    status: false,
                }, {
                    title: '今天要修复100个bug',
                    status: false,
                },
                {
                    title: '今天要修复100个bug',
                    status: true,
                },
                {
                    title: '今天要写100行代码加几个bug吧',
                    status: true,
                }
            ],
            // 图表公用模拟数据
            data: [{
                    name: '2018/09/04',
                    value: 1083
                },
                {
                    name: '2018/09/05',
                    value: 941
                },
                {
                    name: '2018/09/06',
                    value: 1139
                },
                {
                    name: '2018/09/07',
                    value: 816
                },
                {
                    name: '2018/09/08',
                    value: 327
                },
                {
                    name: '2018/09/09',
                    value: 228
                },
                {
                    name: '2018/09/10',
                    value: 1065
                }
            ],
            // 图表一设置
            options: {
                title: '最近七天每天的用户访问量',
                showValue: false,
                fillColor: 'rgb(45, 140, 240)',
                bottomPadding: 30,
                topPadding: 30
            },
            // 图表二设置
            options2: {
                title: '最近七天用户访问趋势',
                fillColor: '#FC6FA1',
                axisColor: '#008ACD',
                contentColor: '#EEEEEE',
                bgColor: '#F5F8FD',
                bottomPadding: 30,
                topPadding: 30
            }
        }
    }
```

computed：计算属性关键词，这里使用三元表达式来计算登录的用户身份。可以根据自己需求进行设置计算式。

```javascript
    computed: {
        role() {
            // 利用三元表达式对用户登录后身份进行判定
            return this.name === 'AsunaCC' ? '超级管理员' : '普通用户';
        }
    }
```

在生命周期函数中调用 handleListener 方法和 changeDate 方法，

```javascript
    created(){
        this.handleListener();
        this.changeDate();
    }
```

activated，deactivated 这两个生命周期函数一定是要在使用了 keep-alive 组件后才会有的。activated（）函数是在进入存在当前函数的页面时触发，deactivated（）函数是在离开存在当前函数的页面时触发。两者常常配套使用。

```javascript
    // 在vue对象存活的情况下，进入当前存在activated()函数的页面时，一进入页面就触发
    activated(){
        this.handleListener();
    }

    // 退出当前存在deactivated()函数页面时触发
    deactivated(){
        // 清除事件监听
        window.removeEventListener('resize', this.renderChart);
        // 清除监听
        bus.$off('collapse', this.handleBus);
    }
```

对图表中所使用的模拟时间进行更改，替换成为当前日期以及其他对应的时间。

Date：时间对象

- getTime（）：获取 1970 年 1 月 1 日至今的毫秒数。
- gitFullYear（）：从 Date 对象以四位数字返回年份。
- getMonth（）：从 Date 对象返回月份 (0 ~ 11)。所以在使用时需要加上 1。
- getDate（）：从 Date 对象返回一个月中的某一天 (1 ~ 31)。

```javascript
    changeDate(){
        // 获取 1970 年 1 月 1 日至今的毫秒数。
        const now = new Date().getTime();
        this.data.forEach((item, index) => {
            // 将data中的模拟数据转化为当前日期为基准的时间
            const date = new Date(now - (6 - index) * 86400000);
            // 将毫秒数转化为对应的日期时间并赋予给data.name，getMonth返回的是0~11所以要加1
            item.name = `${date.getFullYear()}/${date.getMonth()+1}/${date.getDate()}`
        })
    }
```

通过 bus.$on 接受信息，并在接受数据之后调用 handleBus 方法。监听浏览器尺寸，当浏览器尺寸发生变化时，调用 renderChart 方法。

```javascript
    handleListener(){
        // 通过bus监听事件，在接受数据后调用handleBus方法
        bus.$on('collapse', this.handleBus);
        // 通过事件监听，判定浏览器尺寸，调用renderChart方法对图表进行重新渲染
        window.addEventListener('resize', this.renderChart)
    }
```

启用 setTimeout 进行延迟刷新，形成过渡动画。

```javascript
    handleBus(msg){
        setTimeout(() => {
            this.renderChart()
        , 300);
    }
```

分别对两个图表进行重新渲染。

```javascript
    renderChart(){
        // bar 图表重新渲染
        this.$refs.bar.renderChart();
        // line 图表重新渲染
        this.$refs.line.renderChart();
        }
    }
```

### 创建登录组件

登录组件主要由提交表单和提交按钮组成。

el-form：form 表单

- model：表单数据对象。
- rules：表单验证规则。
- ref：给元素或子组件注册引用信息。

el-form-item：表单列表

- prop：设置需要校验的字段名。

el-input：输入框

- placeholder：输入框未输入之前所显示的文字。

el-button：按钮

- slot：插槽，进行具名分发。设置为 prepend 就是将当前内容放置在前面。还可以设置为 append 就是将当前内容放置在后面。

在 `components/page` 目录下创建 Login.vue：

```html
<template>
  <!-- 登录组件 -->
  <div>
    <el-form
      :model="param"
      :rules="rules"
      ref="login"
      label-width="0px"
      class="ms-content"
    >
      <!-- 用户名表单 -->
      <!-- prop设置需要校验的字段名 -->
      <el-form-item prop="username">
        <el-input v-model="param.username" placeholder="username">
          <!-- 输入框中的图标按钮。slot 具名分发，设置为 prepend就是将这个图标放置在前面。还可以设置为 append 就是将这个图标放置在后面 -->
          <el-button slot="prepend" icon="el-icon-lx-people"></el-button>
        </el-input>
      </el-form-item>

      <!-- 密码表单 -->
      <el-form-item prop="password">
        <el-input
          type="password"
          placeholder="password"
          v-model="param.password"
          @keyup.enter.native="submitForm()"
          ><!-- 按键 “enter” 抬起时调用submitForm 事件 
                    .native - 作用是给自定义的组件添加原生事件 -->
          <el-button slot="prepend" icon="el-icon-lx-lock"></el-button>
        </el-input>
      </el-form-item>

      <!-- 登录按钮 -->
      <div class="login-btn">
        <el-button type="primary" @click="submitForm()">登录</el-button>
      </div>
      <!-- Tips 提示 -->
      <p class="login-tips">Tips : 用户名和密码随便填。</p>
    </el-form>
  </div>
</template>
```

#### 登录组件 js 部分

组件中所使用的数据：包括默认登录的管理员账户名和密码以及登录时的验证规则。

```javascript
    data: function() {
        return {
            param: {
                username: 'AsunaCC',
                password: '123123',
            },
            rules: {
                // 验证规则：required：是否必填，message：未通过验证后提示信息，trigger：验证触发，blur：失去焦点时触发
                username: [{ required: true, message: '请输入用户名', trigger: 'blur' }],
                password: [{ required: true, message: '请输入密码', trigger: 'blur' }],
            },
        };
    }
```

登录按钮点击之后所触发的事件，用于检验用户登录信息。获取登录验证信息之后做出对应的命令。如果成功则将用户名传输到本地存储中，并将页面跳转到首页组件上。如果验证失败则提示错误。

```javascript
    methods: {
        submitForm() {
            // 获取ref注册的引用信息
            // validate 是Vue提供的一个表单校验库，可以帮助我们快速的进行表单验证
            this.$refs.login.validate(valid => {
                if (valid) {
                    // 如果通过校验，则将路由转到首页组件上，从而实现登录成功后组件的跳转
                    this.$message.success('登录成功');
                    // 将用户名传入本地存储
                    localStorage.setItem('ms_username', this.param.username);
                    this.$router.push('/');
                } else {
                    // 如果为通过校验，则提示重新输入账号和密码
                    this.$message.error('请输入账号和密码');
                    console.log('error submit!!');
                    return false;
                }
            });
        },
    },
};
```

### 配置路由

想要进入系统首页那肯定是需要进行登录的。所以在创建好登录和首页界面之后，我们就需要对其进行路由配置以实现我们要求的效果。

在 `./router/index.js` 中输入以下代码：

```javascript
import Vue from 'vue';
import Router from 'vue-router';

Vue.use(Router);

export default new Router({
  routes: [
    {
      path: '/',
      //设置重定向，将 Dashboard 组件设为默认路由组件
      redirect: '/dashboard',
    },
    {
      path: '/',
      component: () => import('../components/common/Home.vue'),
      meta: { title: '自述' },
      children: [
        {
          //此时的系统首页是嵌套在 Home 组件当中的
          path: '/dashboard',
          component: () => import('../components/page/Dashboard.vue'),
          meta: { title: '系统首页' },
        },
      ],
    },
    {
      path: '/login',
      component: () => import('../components/page/Login.vue'),
    },
  ],
});
```

这样便可以对这两个页面进行访问。但是又有一个新的问题：因为我们是将 Dashboard 首页组件设置为默认路由组件的，所以项目一运行就会自动跳转到 Dashboard 首页组件。并没有实现我们期望中的先进行登录之后再跳转到首页组件去的效果。

我们要想实现这个效果就需要引入一个新的概念：路由的导航守卫。它的作用便是通过跳转或取消的方式守卫导航。所以我们可以通过 `router.beforeEach` 来注册一个全局前置守卫，对路由的跳转进行一些设置。

在 `src/main.js` 中输入以下代码：

```javascript
import Vue from 'vue';
import App from './App.vue';
import router from './router';
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI, {
  size: 'small',
});

Vue.config.productionTip = false;

//设置全局前置守卫
//这个守卫方法会接受三个参数：
// to：Route ：即将要去往的路由对象，通过这个参数来设置路由的去处。
// from：Route ：当前导航正要离开的路由，通过这个参数来设置路由的出发处。
// next：Function ：这个方法是必须要进行调用的，通过这个参数来resolve这个钩子函数
// next（）：进行下一个钩子，也就是下一个应该去跳转的路由
// next(false)：中断当前导航。
// next('/')：跳转到一个不同的地址，当前导航中断，进行新的导航
// next(error)：终止该导航，并将错误传递给router.onError（）注册的回调。

router.beforeEach((to, from, next) => {
  //对页面的标题进行设置，获取路由元信息当中的title
  document.title = `${to.meta.title} | vue-manage-system`;
  //获取本地存储的用户名
  const role = localStorage.getItem('ms_username');
  //判断是否存在用户名以及下一个钩子是否是跳转到 '/login'
  if (!role && to.path !== '/login') {
    //跳转到 '/login'
    next('/login');
  } else {
    next();
  }
});

new Vue({
  router,
  render: (h) => h(App),
}).$mount('#app');
```

此时，我们运行该项目就会发现，虽然我们默认的页面是系统首页。但是在第一次进入时我们会因为没有登录而跳转到登录界面，经过登录之后才会跳转回系统首页。



# 实验楼课程

+ 报错：无法加载文件C:\Users\Administrator\AppData\Roaming\npm\vue.ps1因为在此系统上禁止运行脚本……解决办法

执行：set-ExecutionPolicy RemoteSigned，然后选择Y

## 创建一个VUE项目

输入命令 `vue --version` 查看版本信息：

```bash
vue --version
```

我们输入命令创建一个名为 `vue-mt-system` 的项目：

```bash
vue create vue-mt-system
```

此时会提示我们进行选择，由于后面的课程会进行 `Sass` 的教学，所以我们选择末尾的自定义选项（脚手架的默认配置中是没有 Sass 依赖的）：

![创建项目](https://doc.shiyanlou.com/courses/2824/1347963/d20fa97b2e28941eb1ec4b72327b328d-0)

我们需要使用**空格键**来确认 `CSS Pre-processors` 选项，按下回车键进行确认。

![图片描述](https://doc.shiyanlou.com/courses/2824/1347963/3491906c1345cc4e8b836b8f4daddd91-0)

后面的配置（除了最后一项）都是选择默认项所以 **直接回车** 即可。

Save this as a preset for future projects? 输入 y。

最后一项是选择安装依赖的方式，我们选择 `Use NPM`。

![图片描述](https://doc.shiyanlou.com/courses/2824/1347963/54f700feb8fc1a7708176d3b3a30df90-0)

创建完毕之后我们通过命令行进入目标文件夹。

```bash
cd vue-mt-system
```

为了满足实验楼的 Web 服务要求，我们需要进行一些配置。我们在 `vue-mt-system` 目录下创建名称为 `vue.config.js` 的配置文件（文件名称要一致），在里面填入下面内容：

```js
const HOST = process.env.HOST;
module.exports = {
  publicPath: './',
  productionSourceMap: false,
  devServer: {
    host: HOST || '0.0.0.0',
    open: true,
    disableHostCheck: true,
  },
};
```

写好配置文件后，使用以下命令启动项目：

```bash
npm run serve
```

出现以下结果就说明项目已经编译成功了：

![项目启动成功](https://doc.shiyanlou.com/courses/2824/1456545/13b484daf0b8825dd68a4fa511458acd-0)

我们点击实验楼右侧选择列表中的 **Web 服务** 按钮，就可以打开界面并将看到 Vue-cli 创建的初始效果。

![图片描述](https://doc.shiyanlou.com/courses/2824/1347963/9dbfbd1b1506cef750e414a031d42ae4-0)

关于 Vue-cli 项目目录功能分类以及其它细节讲解，我们会放到实战的时候细说，前期主要目的是进行基础技能的学习。

如果没有自动启动可以网页端输入`http://localhost:8080/`打开。

#### 基础值绑定

打开 `src/App.vue` 文件，然后用下方的代码进行替换：

```js
<template>
  <div id="app">我的名字是：{{name}}</div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      name: "mt"
    };
  }
};
</script>

<style lang="scss">
</style>
```

打开 WEB 服务，我们会发现界面发生如下改变：

![双括号数据绑定](https://doc.shiyanlou.com/courses/2824/1456545/51ac4f8fb9e9f8dc7606d240ffe412f1-0)

数据绑定最常见的形式就是使用双括号 `{{}}` 进行绑定，Vue 会自动读取 data 中同名的数据进行数据绑定。而在 `{{}}` 中支持单个 JS 表达式操作如：三元表达式，而其余的例如：if/else、var 等不符合要求的语句则不支持。

#### HTML 语句渲染

如果我们需要渲染 HTML 语法，则不能直接使用双括号进行操作，双大括号会将数据解释为普通文本，而非 HTML 代码，需要采用 Vue 提供的 `v-html` 指令来进行，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    我的名字是：
    <span v-html="name"></span>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        name: "<span style='color:red'> mt </span>",
      };
    },
  };
</script>
```

![html语句渲染](https://doc.shiyanlou.com/courses/2824/1456545/85a384009c2601690517d5f7179d48c8-0)

##### span和`<p>`

关于`<span>`，把span改为<p>

~~~
<template>
  <div id="app">
    我的名字是：
    <p v-html="name"></p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        name: "<span style='color:red'> mt </span>",
      };
    },
  };
</script>
~~~

![image-20211210152557406](E:\Document\Typora\img\image-20211210152557406.png)

`<p>`标签是引入一个新的段落，于是就会形成一个新的块元素。例如`<p>我是一个块元素</p>`显示是这样的



我是一个块元素

`<span>`标签只是相当于一个看不见的封装，是一个内联元素，把你需要的东西封装进这个span，而span并不会直接影响内容的显示。比如<span>我是内联元素</span>，显示为： 我是内联元素。外观是没区别的。之所以封装起来，是因为这样可以对你想封装的内容定义它的样式。



#### 属性值绑定

如果需要修改 HTML 标签的属性值（包括自定义属性），我们需要使用 `v-bind` 指令来进行修改，通常我们会使用它的简写方式 `:` 来书写，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <button>Button</button>
    <br />
    <button v-bind:disabled="flag">Button</button>
    <br />
    <button :disabled="flag">Button</button>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        flag: true,
      };
    },
  };
</script>
```

![属性值绑定](https://doc.shiyanlou.com/courses/2824/1456545/436b71e5db047755b21b0065faac7e49-0)

`<br>`标签只是简单地开始新的一行，而当浏览器遇到`<p>`标签时，通常会在相邻的段落之间插入一些垂直的间距。

#### 条件渲染

我们在写 JS 代码的时候，经常会使用到 if/else 来进行判断操作，而 Vue 能够让我们通过指令的方式来直接对内容代码进行控制，极大的简化了操作过程。

对应的指令就是 `v-if` 与 `v-else`，它表示的含义和判断布尔值的过程也与原生的 JS 保持一致，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <div v-if="flag">这里是为true的结果</div>
    <div v-else>这里是为false的结果</div>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        flag: true,
      };
    },
  };
</script>
```

![条件渲染](https://doc.shiyanlou.com/courses/2824/1456545/f2c318f477aaec1e07746a53e187e081-0)

如果我们有多个内容需要进行判断，借助 `v-else-if` 即可实现，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <div v-if=" flag == 0">值为 0</div>
    <div v-else-if=" flag == 1">值为 1</div>
    <div v-else>值为其它</div>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        flag: 1,
      };
    },
  };
</script>
```

![多个条件渲染](https://doc.shiyanlou.com/courses/2824/1456545/4a4dba92df218afccfbfc64f20fb3d14-0)

#### Class 绑定

前面我们说到了 Vue 绑定属性值的方法，即使用 `v-bind` 或者它的简写方式 `:`，利用这个特性 Vue 也提供了直接操作 Class 与 Style 的指令，帮助我们更好地进行样式的控制和切换。要注意 `v-bind:class` 指令可以和普通的 `class` 一起存在，编译的时候 Vue 会自动把它们拼合在一起。例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <div :class="{ 'red': flag }" class="text">class绑定</div>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        flag: true,
      };
    },
  };
</script>

<style lang="scss">
  .text {
    font-size: 16px;
  }
  .red {
    color: red;
  }
</style>
```

![class绑定](https://doc.shiyanlou.com/courses/2824/1456545/c93590b2ed6641641b99b8bf36c87711-0)

:class是`v-bind:class`的简写。

动态绑定，如果class改变可以相应地改变。



我们也可以添加多个元素进行展示：

```html
<div :class="{ 'red1': flag1, 'red2': flag2 }"></div>
```

除了简单的映射，Vue 还支持逻辑判断表达式，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <div :class="[ flag ? 'red' : 'bule'  ]">class判断</div>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        flag: false,
      };
    },
  };
</script>

<style lang="scss">
  .red {
    color: red;
  }
  .bule {
    color: blue;
  }
</style>
```

![class判断](https://doc.shiyanlou.com/courses/2824/1456545/92d9f57febebf3192072b519a1776524-0)

#### 数据监听-computed计算属性

在很多时候我们都需要去根据数据的变化来相应的进行一些操作，而 Vue 提供了两个属性来实现这个功能，分别是计算属性 `computed` 和侦听器 `watch` 。

计算属性的关键词为 `computed`，写法如下图所示。它的每个对象都类似 `data` 对象里的值，调用也保持方法一致。属性的值由内部的函数体进行返回，计算属性会自动监听函数体中 **响应式依赖** 的值变化，从而对应的进行改变。

特别注意的是，如果 **响应式依赖** 没有发生改变，则不会重新进行计算，可以节省性能开销，从而进行复杂的逻辑计算。

例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <p>number的值为：{{number}}</p>
    <p>计算属性返回的值为：{{monitorData}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        number: 2,
      };
    },
    computed: {
      monitorData() {
        return this.number * 10;
      },
    },
  };
</script>
```

![computed计算属性](https://doc.shiyanlou.com/courses/2824/1456545/cc236cc0253cc41ad6497b18fe4697b3-0)

#### 数据监听-watch侦听器

watch 的写法和 computed 类似，区别是它的对象是所要监听的对象而不是返回对象，一旦监听对象值发生变化就会执行一遍函数体。watch 适用于根据值的改变，从而进行一系列业务操作（包括数据获取）的场景，如果是单一的属性复杂计算，请使用计算属性。

watch 侦听器的属性如下所示：

- handler 表示回调函数，当监听对象的数据发生变化时就会执行此函数。
- immediate 表示是否在侦听开始之后被立即调用（默认为 false），绑定之后会立即执行 handler 函数体。
- deep 表示是否深度监听此对象（默认为 false），主要用于解决 Vue 不能直接监听到 Object 对象属性地添加或删除问题。如果 deep 为 true 时，监听器会一层层的往下遍历，给对象的所有属性都进行监听。

我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <p>number的值为：{{number}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        number: 2,
      };
    },
    watch: {
      // 监听对象为 number
      number: {
        // 表示所要执行的函数体
        handler: function (newValue, oldValue) {
          // 首次执行没有旧值 oldValue 的值将为 undefined
          console.log('旧的属性值：' + oldValue);
          console.log('新的属性值：' + newValue * 2);
        },
        // 在侦听开始之后被立即调用，所以控制台会有值输出
        immediate: true,
        // 进行深度监听（此次监听的数据不是一个 Object，可以为 fasle）
        deep: true
      },
    },
  };
</script>
```

运行程序之后按下 F12 打开开发者工具，选择第二个选项打开控制台，就可以查看到回调函数执行所输出的内容：

![查看监听结果](https://doc.shiyanlou.com/courses/2824/1456545/fc47d7a5c93b8c57fcf05140e75fff7d-0)

#### 事件处理

事件函数是一个经常用到的内容，在 Vue 中想实现自定义事件，需要先加上 `methods` 对象，然后在里面写上对应的方法名称和函数体。使用 `v-on` 指令或者它的简写 `@` 符号可以在标签中绑定此事件，例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app">
    <button v-on:click="handleBtn">触发事件v-on</button>
    <button @click="handleBtn">触发事件@</button>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        number: 2,
      };
    },
    methods: {
      handleBtn() {
        console.log(this.number);
      },
    },
  };
</script>
```

![界面展示](https://doc.shiyanlou.com/courses/2824/1347963/a07c07182bf742cc3cd72aa294c66529-0)

然后按下 F12 打开开发者工具，选择第二个选项打开控制台。随后按下界面上的按钮，若控制台有输出 number 的值：2，则表示事件触发成功。

事件监听也支持直接把 JS 语句直接写在 `""` 中，如：

```html
<button v-on:click="number = 3">触发事件v-on</button>
```

Vue.js 为 `v-on` 提供了一系列的修饰符，来帮助开发者更便于进行代码的编写，大家有兴趣可以自己试试效果。

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```

### Vue生命周期

每一个 Vue 的实例都有自己的生命周期，并运行生命周期钩子函数，让开发者在不同的生命周期阶段，运行对应的业务逻辑代码。我们主要了解各个周期的内容和日常开发所进行的相对应的操作即可。

**初始化事件**

- beforeCreate
- created

在 beforeCreate 阶段，只有一个空的实例，data 和 methods 中的数据还没有初始化。

在 created 阶段，data 和 methods 已经初始化好了，如果需要进行数据请求则可以在这个钩子中进行操作。

**模板渲染挂载**

- beforeMount
- mounted

在 beforeMount 阶段，模板数据内容已经编译好了，但是还没去挂载到界面中。

在 mounted 阶段，模板数据已经挂载好了，也就是我们眼中看到的界面样子。如果需要对 Dom 元素进行操作，就可以在这里进行。

**更新事件**

- beforeUpdate
- updated

在 beforeUpdate 阶段，新的数据已经渲染好了，但是还没去更新。

在 updated 阶段，新的数据和实例中的 data 已经同步完成。

**销毁事件**

- beforeDestroy
- destroyed

在 beforeUpdate 阶段，销毁之前的钩子，所有的数据都还没进行销毁。

在 destroyed 阶段，所有的数据已经销毁完成，组件中的所有数据都是不可用了。

#### 用法

生命周期函数钩子的用法是一致的，写出对应的钩子名称与函数体即可，我们可以在控制台看到输出的值。例如我们在 `App.vue` 中写入以下内容：

```html
<template>
  <div id="app"></div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {};
    },
    // 调用生命周期函数
    mounted() {
      console.log('直接输出值');
      this.handleBtn();
    },
    methods: {
      handleBtn() {
        console.log('调用函数输出值');
      },
    },
  };
</script>
```

![图片描述](https://doc.shiyanlou.com/courses/2824/1347963/058112373a836ab6030312e864d95827-0)

## Vue进阶与Sass框架讲解

### 组件

不论是 Vue 还是 React 都提倡组件式开发，对功能模块进行拆分和复用，能最大限度的节省成本。Vue 拆分出的所有组件同时也算是 Vue 的一个实例，拥有提供相同的指令和函数钩子。本节实验我们使用上一个实验创建出来的项目环境来进行教学演示，首先重新编写 App.vue 文件：

`App.vue` 文件：

```html
<template>
  <div id="app">这里是父组件</div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {};
    },
  };
</script>

<style lang="scss"></style>
```

我们一般将引用其它组件的地方称为父组件，而被调用的组件称为子组件，首先进入到 `components` 目录下修改 `HelloWorld.vue` 这个文件夹的内容。

`HelloWorld.vue` 文件：

```html
<template>
  <div class="color-red">这里是子组件的内容</div>
</template>

<script>
  export default {
    name: 'HelloWorld',
    data() {
      return {};
    },
  };
</script>

<style lang="scss">
  .color-red {
    background: red;
  }
</style>
```

此时拥有了两个界面，下一步就是引入子组件并通过 `component` 指令将子组件注册到 `App.vue` 实例中，并使用 **标签** 的形式在 `template` 里进行展示。

修改 `App.vue` 文件：

```html
<template>
  <div id="app">
    这里是父组件
    <HelloWorld></HelloWorld>
  </div>
</template>

<script>
  import HelloWorld from './components/HelloWorld.vue';

  export default {
    name: 'App',
    data() {
      return {};
    },
    components: {
      HelloWorld,
    },
  };
</script>

<style lang="scss"></style>
```

编写好代码之后启动项目，我们在工程目录运行 `npm run serve` 命令，编译好之后，点击编辑器右侧菜单的 **Web 服务** 按钮即可浏览。

```bash
npm run serve
```

查看界面，会发现子组件已经引入到了父组件中：

![组件展示](https://doc.shiyanlou.com/courses/2824/1456545/bedc13a284cc38cd24f81de8a47c124e-0)

### 宏观定义

在此我在这里介绍几个知识点，详细内容大家也可以去查看官方文档 [Vue 组件详情](https://cn.vuejs.org/v2/guide/components.html)。

**1. 组件允许进行任意次数的复用。**

大家可以多复制几次组件的标签，会发现界面会发生相应的变化，这就是组件的复用属性。

**2. data 必须是一个函数。**

在 Vue-cli 脚手架创建的项目中，每个 `.vue` 文件都是一个小组件，可以看到 data 对象其实是一个有着 return 的返回值函数。这里大家需要尤其的注意，如果不使用 return 的方式而是直接包裹对象，组件之间的数据会互相影响，产生不可预估的后果。

**3. Vue 能够全局注册组件。**

顾名思义，全局注册组件就是在整个 Vue 项目中注册目标组件，并直接应用到每个子组件中，此方法一般用于导入外部的插件或者框架，例如：`Element`、`Axios` 等，在后面的项目实战中将使用到此技术。



### 组件传值

组件之间并不是相互独立的，而是有数据流动，那么就要涉及到父子组件传值的问题。

#### Prop 传值

在父组件中，直接对子组件的标签添加属性并传入数据内容，通常会借助 `v-bind` / `:` 来传入父组件中的 data 值。

`App.vue` 文件：

```html
<template>
  <div id="app">
    这里是父组件
    <HelloWorld :name="name"></HelloWorld>
  </div>
</template>

<script>
  import HelloWorld from './components/HelloWorld.vue';

  export default {
    name: 'App',
    data() {
      return {
        name: '小明',
      };
    },
    components: {
      HelloWorld,
    },
  };
</script>

<style lang="scss"></style>
```

当父组件的数据输入到子组件中，子组件就需要使用 `props` 指令来接受父组件的内容。

`HelloWorld.vue` 文件：

```html
<template>
  <div>
    <span class="color-red">这里是子组件的内容</span>
    <br />
    <span>子组件接收到的数据为： {{name}}</span>
  </div>
</template>

<script>
  export default {
    name: 'Children',
    data() {
      return {};
    },
    props: {
      name: {
        type: String, // 定义了传入值的类型
        default: null, // 定义默认值
      },
    },
  };
</script>

<style lang="scss">
  .color-red {
    background: red;
  }
</style>
```

此时界面就已经接收到了父组件的值，运行代码后，即可看到如下效果。

![组件传值](https://doc.shiyanlou.com/courses/2824/1456545/b60bf10e6068ebb3fc91aa62a682e988-0)

#### 子组件向父组件传值

子组件向父组件传值稍微复杂一些，需要使用到函数的参数来进行传值，并且也有专门的指令 `$emit` 来进行函数的触发。我们在子组件中添加 data 值，并且在生命周期钩子函数中使用 `$emit` 指令来触发传值函数。

`HelloWorld.vue` 文件：

```html
<template>
  <div></div>
</template>

<script>
  export default {
    name: 'Children',
    data() {
      return {
        ege: 12,
      };
    },
    props: {
      name: {
        type: String, // 定义了传入值的类型
        default: null, // 定义默认值
      },
    },
    // 在 mounted 生命周期里直接传递数据到父组件中
    mounted() {
      // 参数允许传入多个
      this.$emit('egeFn', this.ege);
    },
  };
</script>

<style lang="scss">
  .color-red {
    background: red;
  }
</style>
```

`App.vue` 文件：

```html
<template>
  <div id="app">
    这里是父组件
    <HelloWorld :name="name" @egeFn="egeParent"></HelloWorld>
    <br />
    <span>父组件接收到的值为：{{age}}</span>
  </div>
</template>

<script>
  import HelloWorld from './components/HelloWorld.vue';

  export default {
    name: 'App',
    data() {
      return {
        name: '小明',
        age: null,
      };
    },
    components: {
      HelloWorld,
    },
    methods: {
      egeParent(data) {
        // 这里参数就是子组件的值
        this.age = data;
      },
    },
  };
</script>

<style lang="scss"></style>
```

此时界面显示为：

![子组件向父组件传值](https://doc.shiyanlou.com/courses/2824/1456545/91853086217189e3c5135bb0b21de3d2-0)

我们来重新阐述数据传递的逻辑：

- 子组件的 data 中定义了年龄。
- 子组件在生命周期里借助 `$emit` 指令派发了名为 `egeFn` 的函数，参数为派发函数名称与年龄。
- 父组件在标签中监听同名 `egeFn` 事件，并借助 `@/v-on` 绑定到自身的 `egeParent` 事件函数。
- 当 `v-on` 监听到子组件派发的同名事件时，子组件的数据会当作参数传入 `egeParent` 中。
- 把参数赋值给父组件中的 age 并双向绑定到界面的相应位置，界面进行展示。

`$emit()` 的第一个参数为父组件的监听事件名称，其余参数为需要传递的数据，在父组件的 `egeParent` 参数中也是一一对应的。如果有多个业务事件触发，那么同样的只需要在父组件中写多个监听函数即可。

### 组件数据监听

我们学会了父组件传递数据给子组件，也就是数据会保存在 `props` 对象。

在实际的业务开发中经常需要对传入的数据进行编辑，但是有一点很重要，Vue 不允许直接修改 `props` 的数据，必须赋值给子组件中的数据，然后再进行操作。

提到数据监听，应该很自然的想到之前提到的 `watch` 和 `computed` 指令，具体用法可以查看下面的例子。

`App.vue` 文件：

```html
<template>
  <div id="app">
    这里只展示子组件的内容
    <!-- 传入了 number 值给子组件 -->
    <HelloWorld :number="number"></HelloWorld>
  </div>
</template>

<script>
  import HelloWorld from './components/HelloWorld.vue';

  export default {
    name: 'App',
    data() {
      return {
        number: 10,
      };
    },
    components: {
      HelloWorld,
    },
  };
</script>

<style lang="scss"></style>
```

`HelloWorld.vue` 文件：

```html
<template>
  <div>
    <p>子组件使用watch接收到的数据为：{{wnum}}</p>
    <p>子组件使用computed接收到的数据为：{{cnum}}</p>
  </div>
</template>

<script>
  export default {
    name: 'Children',
    data() {
      return {
        wnum: null,
      };
    },
    props: {
      number: {
        type: Number, // 定义了传入值的类型
        default: null, // 定义默认值
      },
    },
    watch: {
      // 接收数据并赋值给 wnum
      number: {
        handler(data) {
          this.wnum = data + 1;
        },
        immediate: true, // 一开始就进行接收
      },
    },
    computed: {
      // 监听函数体的数据，并返回对应的数据
      cnum() {
        return this.number * 2;
      },
    },
  };
</script>

<style lang="scss"></style>
```

此时界面展示为：

![组件数据监听](https://doc.shiyanlou.com/courses/2824/1456545/1f7a167400d4da32ccd68feddefff2b9-0)

### MiXin混入

我们学会了如何拆分内容并划分为组件，然后个根据业务的需要再引入到对应的界面中，并进行数据交互。

当你需要把功能函数进行拆分时，可能会直接想到新增 JS 文件然后再引入，并在对应的位置进行触发。但是 Vue 中有多种指令钩子，如果逐步写到对应的位置，不但耗时耗力并且容易出错。

Vue 针对复杂场景提供了一种更加方便的引用方式：`MiXin`，它可以直接混入到当前 Vue 界面中，并且所有混入对象的选项将被 “混合” 进入该组件本身的选项当中。

在 src 目录下新建 `utils` 文件夹，在里面新增一个名为 `mixins.js` 的文件：

`mixins.js` 文件：

```js
// 定义一个混入对象
const myMixin = {
  data() {
    return {
      mixinsData: 123,
    };
  },
  methods: {
    // 这里也可以混入方法
  },
};

export default myMixin;
```

`App.vue` 文件：

```html
<template>
  <div>
    <p>混入的数据为：{{mixinsData}}</p>
  </div>
</template>

<script>
  import myMixin from './utils/mixins.js';
  export default {
    name: 'mixins',
    // 在这里注入Mixin对象
    mixins: [myMixin],
    data() {
      return {};
    },
  };
</script>

<style lang="scss"></style>
```

此时界面已经展示出了对应的数据并且没有任何的报错，也就是说 `minxin.js` 中的文件成功混入了界面的 data 数据当中。我们可以在 `minxin.js` 里书写任何公共的函数或者数据，它都会自动注入到界面当中，极大的提升了开发效率。

当然 `mixins` 支持全局混入，使用全局的时候要异常小心，因为它会影响到每一个实例。

## Sass介绍

[Sass基础教程 Sass快速入门 Sass中文手册 | Sass中文网](https://www.sass.hk/guide/)

Sass 是 CSS 的一个预处理语言，它最主要的作用是用来解决 CSS 的不足点。

我们编写 CSS 语言时，面对各种嵌套、浏览器前缀、大量的重复书写等场景都十分头疼，还无法使用变量，每一个结构相同但细节不一致的样式都必须单独书写，极大地增加了工作量，不断消磨开发者的意志。

为了解决这些痛点，CSS 的预处理语言 Sass 就为此诞生了，除了 Sass 预处理语言中比较著名的还有 `Less` 和 `Stylus`，它们的逻辑都是类似的，区别无非在于写法的不同，所以讲解 Sass 即可。

Sass 不允许直接使用，需要进行编译，而 Vue-cli 脚手架已经帮助我们提供了这样的功能，即在 `.vue` 文件中的 `style` 标签里写上 `lang="scss"` 即可直接使用 Sass 语法。

大家可能会有疑问为什么是写成 `scss`，其实 Sass 最初是类似 `Stylus/Python` 这样的缩进风格代码。但是从第三代开始，放弃了缩进式风格，并且完全向下兼容普通的 CSS 代码，这一代的 Sass 也被称为 Scss，日常开发通常也都是使用此版本。如果我们单独拆分样式文件书写，后缀名也是 `.scss`。

### Sass语法与应用

本节讲解 Sass 使用较为频繁的几个重要知识点：变量、嵌套、计算、继承、注释、文件引入。

#### 变量

Sass 允许像 JS 一样使用变量，所有变量以 `$` 开头。将变量引入到多个单独的样式中，方便进行样式的全局控制。

`App.vue` 文件：

```html
<template>
  <div id="app">
    <p class="text">{{data1}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        data1: '这里是p标签',
      };
    },
  };
</script>

<style lang="scss">
  $mainColor: #e11212;
  .text {
    color: $mainColor;
  }
</style>
```

此时界面展示为：

![Sass变量](https://doc.shiyanlou.com/courses/2824/1456545/6aebcf1e53f687e5338d8d1b215fe49a-0)

#### 嵌套

Sass 的嵌套写法非常的直观，你并不需要像 CSS 那样写很长的前缀，而是直接写在 `{}` 里面，最后就会编译出正常的 CSS 写法，节省了大量的劳动力。

`App.vue` 文件：

```html
<template>
  <div id="app">
    <p class="text">{{data1}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        data1: '这里是p标签',
      };
    },
  };
</script>

<style lang="scss">
  $mainColor: #e11212;
  #app {
    .text {
      color: $mainColor;
    }
  }
</style>
```

按 F12 打开开发者工具并选择工具中左上角的箭头符号，然后放到目标元素身上进行点击，随后查看样式：

![点击目标元素](https://doc.shiyanlou.com/courses/2824/1456545/a424cfa5d268049345e7df2df4786cd4-0)

![Sass嵌套](https://doc.shiyanlou.com/courses/2824/1456545/7df7a8443f40cecdb1efe92c7bc980e2-0)

#### 计算

Sass 允许你直接在代码中进行计算

`App.vue` 文件：

```html
<template>
  <div id="app">
    <p class="text">{{data1}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        data1: '这里是p标签',
      };
    },
  };
</script>

<style lang="scss">
  $mainColor: #e11212;
  #app {
    .text {
      color: $mainColor;
      padding-left: (3px + 7px) * 2 / 5;
    }
  }
</style>
```

padding-left:设置 p 元素的左内边距。

使用开发者工具进行样式查看：

![Sass计算](https://doc.shiyanlou.com/courses/2824/1456545/fb31564eaec324a5aff2326400a30f55-0)

#### 继承

如果一个样式与另外一个样式几乎相同，继承功能可以很好的重用代码，减少代码量，只需借助 `@extend` 指令。

`App.vue` 文件：

```html
<template>
  <div id="app">
    <p class="text">{{data1}}</p>
  </div>
</template>

<script>
  export default {
    name: 'App',
    data() {
      return {
        data1: '这里是p标签',
      };
    },
  };
</script>

<style lang="scss">
  $mainColor: #e11212;
  #app {
    .defult {
      margin: 0px;
      padding: 0px;
      font-size: 16px;
      cursor: default;
      color: $mainColor;
    }
    .text {
      @extend .defult;
    }
  }
</style>
```

我们会看到 `.text` 成功继承了默认的样式：

![Sass继承](https://doc.shiyanlou.com/courses/2824/1456545/96d3312370d212057634c4d9f6a44399-0)

#### 注释

Sass 的注释有两种，也很好理解：

- 标准的 CSS 注释 /_ comment _/ ，会保留到编译后的文件。
- 单行注释 // comment，只保留在 Sass 源文件中，编译后被省略。

#### 文件引入

为了防止 `.Vue` 放入过多代码，通常需要将样式文件和业务代码分开，然后从外部将样式文件进行引入。引入样式文件方式也很简单，假设我们把样式文件放在了同级目录下 `./style/style.scss` 文件中，引入的方式如下：

```css
<style lang="scss">
  @import './style/style.scss';
</style>
```

#### 常用知识点补充

这里补充一个常用的知识点：

```css
.app {
  &-text {
    color: red;
  }
  &:hover {
    color: blue;
  }
}
```

Sass 提供了 `&` 符号来表示父级的标签名称，上面的写法会被编译成：

```css
  .app-text {
    color: red;
  }
  .app:hover {
    color: blue;
  ｝
```

以上就是 Sass 基础且重要的用法，剩余的高级语法和特殊场景大家可以直接前往官网进行学习。

CSS 预处理语言简单易用，除了掌握 Sass 之外，最好也去学习 Less，因为不同的开源 UI 框架所使用预处理语言是不同的，我们经常需要对这些原始样式进行定制化，那么就需要使用对应的预处理语言进行编写。除此之外也不能确定公司使用的是哪一种预处理语句，所以都需要开发者进行掌握。

### 官网学习

[CSS 选择器参考手册 (w3school.com.cn)](https://www.w3school.com.cn/cssref/css_selectors.asp)

`.xx`表示xx类

`*`表示所有元素

直接写表示元素。

比如，`.button` `button`会命中button元素和类名为.button的元素。

`margin-bottom`表示p 元素的下外边距：



## Canvas介绍

`<canvas>` 是 HTML5 新增的元素，使用脚本来绘制图像，它通过高度和宽度属性而定义出的可绘制区域。我们可以通过 JavaScript 代码访问该区域，使用一套完整的绘图函数命令来动态生成图形。它可以用于动画、数据可视化、图片编辑、文字处理、游戏画面以及实时视频处理等方面。

在下一个阶段的项目实战当中，我们会借助 ECharts 框架来进行界面图表的绘制，虽然 ECharts 拥有自己独立的 API，但它也是基于 Canvas 技术来实现的。

学习 Canvas 不仅可以在 ECharts 的样式控制中运用，而且能够帮助我们更好地理解可视化技术的原理。

### 绘制矩形

我们在 `drawRectangle.html` 文件中写入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>绘制矩形</title>
  </head>

  <body>
    <canvas id="drawRectangle" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('drawRectangle');

        // 首先进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建一个画布
          const ctx = canvas.getContext('2d');

          // 2. 基于此画布填充颜色，颜色会应用于下方绘制的图案
          ctx.fillStyle = '#7ed321';

          // 3. 绘制一个填充矩形，坐标是（10，10），宽高是（100，100）
          ctx.fillRect(10, 10, 100, 100);

          // 4. 填充边框颜色，颜色会应用于下方绘制的图案
          ctx.strokeStyle = 'rgba(246,161,16,1)';

          // 5. 绘制一个矩形边框，坐标是（30，30），宽高是（100，100）
          ctx.strokeRect(30, 30, 100, 100);

          // 6. 清除指定的矩形区域，会影响上方所绘制的图案，坐标是（35，35），宽高是（50，50）
          ctx.clearRect(35, 35, 50, 50);
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

写完代码后直接点击右上角的小图标，即可在开发工具中查看界面样式。除此之外也可以鼠标右键点击 `drawRectangle.html` 文件，选择 Open With -> Preview，点击确认进行查看。

![查看界面](https://doc.shiyanlou.com/courses/2824/1456545/5a90214d83f871f46edf2a925ebb4391-0)

所绘画出来的图形：

![绘画矩形](https://doc.shiyanlou.com/courses/2824/1456545/7985700127033ae29fdf604877d7272c-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴）：

- `fillRect(x, y, width, height)`：绘制一个填充矩形。
- `fillStyle(colorString)`：定义颜色来填充矩形（通用）。
- `strokeRect(x, y, width, height)`：绘制一个矩形边框。
- `strokeStyle(colorString)`：定义颜色来填充边框（通用）。
- `clearRect(x, y, widh, height)`：清除指定的矩形区域。
- 必须先绘制颜色再绘制图形，否则会出现不对应的问题。

我们绘画时，是基于目标画布左上角为基准点进行绘制，下面这张图可以比较直观地看出位置坐标情况：

![矩形坐标解释图](https://doc.shiyanlou.com/courses/2824/1456545/6e0c9db6760e4006510c9b69a5c9a243-0)

### 绘制三角形

这里使用路径的命令绘制一个三角形，以此来学习路径相关知识点，在 `canvas` 目录下新建 `drawTriangles.html` 文件，填入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>路径绘制三角形</title>
  </head>

  <body>
    <canvas id="drawTriangles" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('drawTriangles');

        // 首先进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建画布
          const ctx = canvas.getContext('2d');

          // 2. 新建一条路径
          ctx.beginPath();

          // 3. 创建起始点，坐标为（50，50）
          ctx.moveTo(50, 50);

          // 4. 绘制第二个点，坐标为（100，50）
          ctx.lineTo(100, 50);

          // 5. 绘制第三个点，坐标为（100，100）
          ctx.lineTo(100, 100);

          // 6. 闭合线条
          ctx.closePath();

          // 7. 设置边框（画笔）宽度
          ctx.lineWidth = 2;

          // 8. 描边颜色
          ctx.strokeStyle = 'red';

          // 9. 描边
          ctx.stroke();

          // 10. 填充颜色
          ctx.fillStyle = 'rgba(246,161,16,1)';

          // 11. 进行颜色填充
          ctx.fill();
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

我们同样右键点击目标文件，选择 Open With -> Preview，在开发工具中查看使用路径函数命令绘制的图形：

![路径绘制三角形](https://doc.shiyanlou.com/courses/2824/1456545/67f7cb79e3f0952ebb9903da22626fbc-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴）：

- `beginPath()`：表示新建一条路径，图形绘制命令被指向到路径上准备生成路径。
- `moveTo(x, y)`：设置路径的起始点坐标。
- `lineTo(x,y)`：绘制路径上对应顺序的点。
- `closePath()`：闭合路径，会拉一条从当前点到 path 起始点的直线，如果当前点与起始点重合则什么都不做。
- 绘制多个图形需要使用 `ctx.beginPath()` 新建路径，否则会受到通用命令影响。

### 绘制圆形

绘制圆形之前，先对圆组成部分进行解构：圆心（x,y）、半径、开始角度、结束角度、顺/逆时针。

在 `canvas` 目录下，新建 `drawCircular.html` 文件，填入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>绘制圆形</title>
  </head>

  <body>
    <canvas id="drawCircular" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('drawCircular');

        // 首先要进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建画布
          const ctx = canvas.getContext('2d');

          // 2. 设置颜色
          ctx.strokeStyle = 'red';

          // 3. 设置边框宽度（圆环厚度）
          ctx.lineWidth = 10;

          // 4. arc(x, y, r, startAngle, endAngle, anticlockwise)
          // arc( 圆心 x，圆心 y，开始角度，结束角度，是否逆时针 )
          ctx.arc(150, 150, 50, 0, (Math.PI * 3) / 2, false);

          // 5. 进行描边
          ctx.stroke();

          // 6. 新建一条路径，否则会影响上面的图形
          ctx.beginPath();

          // 6. 设置颜色
          ctx.fillStyle = '#7ed321';

          // 7. 绘制图形
          ctx.arc(300, 150, 50, 0, Math.PI, false);

          // 6. 进行填充
          ctx.fill();
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

查看界面展示效果：

![绘制圆形](https://doc.shiyanlou.com/courses/2824/1456545/50370363596e1871eb399aedcbb47864-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴）：

- `arc(x, y, r, startAngle, endAngle, anticlockwise)`：（x, y）为圆心，以 r 为半径，startAngle 为开始角度（默认 3 点钟方向），endAngle 为结束角度。anticlockwise 的值为 true 表示逆时针（默认），false 表示顺时针。
- `lineWidth` 边框厚度（通用）。
- 绘制多个图形需要使用 `ctx.beginPath()` 新建路径。

### 绘制文字

通常情况下我们会直接使用 CSS 来进行文本样式的控制，不过在绘制图表的时候也可以使用 Canvas 来操作文本，以此运用于复杂的场景当中。

在 `canvas` 目录下新建 `drawText.html` 文件，写入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>绘制文字</title>
  </head>

  <body>
    <canvas id="drawText" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('drawText');

        // 首先要进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建画布
          const ctx = canvas.getContext('2d');

          // 2. 设置阴影
          ctx.shadowColor = '#999999';

          // 3. 设置阴影模糊
          ctx.shadowBlur = 2;

          // 4. 设置阴影偏移量
          ctx.shadowOffsetX = 10;
          ctx.shadowOffsetY = 10;

          // 5. 设置文字样式
          ctx.font = 'bold italic 50px fakt-web';

          // 6. 设置填充的颜色
          ctx.fillStyle = '#7ed321';

          // 7. 设置并填充文字文本
          ctx.fillText('这里是文本', 10, 100);
          ctx.strokeText('这里是文本', 10, 200);
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

查看界面样式：

![文本绘制](https://doc.shiyanlou.com/courses/2824/1456545/0305eebdb169aa17e73255dd5a4403fe-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴）：

- `fillText(text, x, y, maxWidth)`：在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。
- `strokeText(text, x, y, maxWidth)`：在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。
- `font`：设置文字样式（font-weight, font-style, font-size, font-family）。
- `textAlign`：文本对齐选项，可选的值包括：start, end, left, right or cente，默认值是 start。
- `textBaseline`：基线对齐选项，可选的值包括：top、hanging、middle、alphabetic、ideographic、bottom，默认值是 alphabetic。
- `direction`：文本方向，可能的值包括：ltr, rtl, inherit。默认值是 inherit。

### 颜色渐变

上方案例中我们使用的都是单一颜色值，展示出来比较单调。Canvas 支持颜色渐变效果，能够让色彩更加丰富。

渐变分为线性渐变与径向渐变，在 ECharts 绘制图表时，经常给图形加上线性渐变来提升美观度。

#### 线性渐变

在 `canvas` 目录下创建 `colorGradient-linear.html` 文件，写入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>线性渐变</title>
  </head>

  <body>
    <canvas id="colorGradient" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('colorGradient');

        // 首先要进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建画布
          const ctx = canvas.getContext('2d');

          // 2. 创建线性渐变方向（起点X1，起点Y1，终点X2，终点y2）
          let lingrad = ctx.createLinearGradient(0, 0, 150, 150);

          // 3. 设置渐变内容（颜色位置 0.0~1.0，颜色）
          lingrad.addColorStop(0.0, '#c6ef9a');
          lingrad.addColorStop(0.2, '#b5ea7b');
          lingrad.addColorStop(0.4, '#a5e65f');
          lingrad.addColorStop(0.6, '#97e245');
          lingrad.addColorStop(0.8, '#2ede6f');
          lingrad.addColorStop(1.0, '#21d363');

          // 3. 绘制图形内容
          ctx.font = 'bold normal 50px fakt-web';

          // 4. 新建路径
          ctx.beginPath();

          // 4. 将渐变图案赋值给填充内容
          ctx.fillStyle = lingrad;

          // 5. 图案绘制
          ctx.fillText('这里是文本', 30, 100);

          // 6. 设置描边颜色和宽度
          ctx.strokeStyle = lingrad;
          ctx.lineWidth = 4;

          // 6. 绘制矩形
          ctx.strokeRect(10, 10, 300, 150);
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

查看界面样式：

![线性渐变](https://doc.shiyanlou.com/courses/2824/1456545/68d2a02ad7b48cde67e5e17da4cb32ac-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴，r 表示半径）：

- `createLinearGradient(x1, y1, x2, y2)`：创建线性渐变，参数表示起点与终点。在上方的案例中，起点指向终点是从左上角指向右下角。
- `addColorStop(number, colorString)`：设置位置与颜色，第一个参数表示位置，范围是 0.0~1.0，第二个参数是颜色值。

#### 径向渐变

在 `canvas` 目录下创建文件 `colorGradient-radial.html` 文件，写入以下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>径向渐变</title>
  </head>

  <body>
    <canvas id="colorGradient" width="500" height="300">
      您的浏览器不支持 Canvas，请更换浏览器！
    </canvas>

    <script type="text/javascript">
      function draw() {
        let canvas = document.getElementById('colorGradient');

        // 首先要进行浏览器支持性判断
        if (canvas.getContext) {
          // 1. 创建画布
          const ctx = canvas.getContext('2d');

          // 2. 创建径向渐变范围（圆心 X1，圆心 Y1，半径 r1，圆心 X2，圆心 y2，半径 r2）
          let Radialgrad = ctx.createRadialGradient(50, 50, 10, 50, 50, 50);

          // 3. 设置渐变内容（颜色位置 0.0~1.0，颜色）
          Radialgrad.addColorStop(0.0, '#c6ef9a');
          Radialgrad.addColorStop(1.0, '#21d363');

          // 4. 设置填充颜色
          ctx.fillStyle = Radialgrad;

          // 6. 绘制矩形
          ctx.fillRect(0, 0, 100, 100);
        }
      }
      // 进行绘画
      draw();
    </script>
  </body>
</html>
```

查看样式：

![径向渐变](https://doc.shiyanlou.com/courses/2824/1456545/59719231eea0637e8932b030a56133a4-0)

可以根据代码注释来理解大致的流程，这里进行部分功能阐述（以下 x 与 y 表示坐标轴，r 表示半径）：

- `createRadialGradient(x1, y1, r1, x2, y2, r2)`：创建径向渐变，参数表示内部圆与外部圆，颜色的渐变产生于两个圆之间。
- `addColorStop(number, colorString)`：设置位置与颜色，第一个表示位置，范围是 0.0~1.0，第二个参数是颜色值。

## ECharts

官网[Examples - Apache ECharts](https://echarts.apache.org/examples/zh/index.html)

ECharts 是一个使用 JavaScript 实现的开源可视化库。提供直观，交互丰富，可高度个性化定制的数据可视化图表。

ECharts 由百度技术团队进行开发，文档设计符合国人的习惯，十分友好。除此之外，社区资源丰富，现实中大部分的业务组件都可以在社区上找到身影，给开发人员提供编码思路。

我们继续使用第二节实验搭建起来的 `vue-mt-system` 项目进行演示，鼠标右键目标项目并选择 `Open in Terminal` 打开控制台，在控制台输入安装 ECharts 命令：

```bash
npm install echarts@4.6.0 --save
```

安装之后打开 `src/main.js` 文件，添加以下内容：

```js
import Vue from 'vue';
import App from './App.vue';

Vue.config.productionTip = false;

// 引入 ECharts
import echarts from 'echarts';
// 将 ECharts 挂载到 Vue 原型链中，引用时只需要使用 this.$echarts 即可
Vue.prototype.$echarts = echarts;

new Vue({
  render: (h) => h(App),
}).$mount('#app');
```

此时已经把 ECharts 插件引入到了项目中，我们在 `components` 目录下新建 `Chart.vue` 文件。此时可以参考 ECharts 官方文档中的案例进行代码编写，官方文档地址：[ECharts 官方文档](https://echarts.apache.org/examples/zh/index.html)。

我们参照文档第一个折线图案例，向 `Chart.vue` 文件中添加内容：

~~~
<template>
  <div>
    <div id="chart" style="width:400px;height: 400px"></div>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        chart: null,
      };
    },
    mounted() {
      // 在生命周期中调用函数
      this.draw();
    },
    methods: {
      draw() {
        // 基于准备好的 dom，初始化 echarts 实例
        this.chart = this.$echarts.init(document.getElementById('chart'));

        let option = {
          // X 轴数据
          xAxis: {
            type: 'category',
            data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
          },
          // Y 轴数据
          yAxis: {
            type: 'value',
          },
          // 类型控制、数据列表、样式操作等区域
          series: [
            {
              data: [820, 932, 901, 934, 1290, 1330, 1320],
              type: 'line',
            },
          ],
        };

        // 创建图表
        this.chart.setOption(option);
      },
    },
  };
</script>

<style lang="scss" scoped></style>
~~~

上方代码列举了较为常用的部分配置，将代码与刚刚初始案例的 `option` 进行替换，然后观察界面样式：

![修改之后的样式图](https://doc.shiyanlou.com/courses/2824/1456545/c7485b98e03d92b9a26435bfb16c3fb4-0)

我们可以去修改里面的参数，观察界面图表变动，以此来加深印象。除了官方文档提供的案例之外，社区的案例更加丰富多彩，点击后方链接前往查看 [ECharts 社区案例链接](https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all)。

## DataV

DataV 组件库基于 Vue（也提供 react 版本），主要用于构建大屏数据展示页面即数据可视化，具有多种类型组件可供使用，如：边框、装饰等。

除了基本静态图案，它还提供数据展示图表，如：动态表格切换、胶囊图、水位图等组件。官方文档的链接地址为：[DataV 官方文档地址](http://datav.jiaminghi.com/guide/#用前必看)

同样的，我们需要先在项目中安装对应的依赖才能使用该组件库，在工程目录下的控制台中输入安装命令：

```bash
npm install @jiaminghi/data-view
```

安装完毕后，在 `main.js` 文件中进行引用与全局注入：

```js
import Vue from 'vue';
import App from './App.vue';

Vue.config.productionTip = false;

// 引入 ECharts
import echarts from 'echarts';
// 挂载到 Vue 原型链中，引用时只需要使用 this.$echarts 即可
Vue.prototype.$echarts = echarts;

// 引入 DataV
import dataV from '@jiaminghi/data-view';
// 全局注入
Vue.use(dataV);

new Vue({
  render: (h) => h(App),
}).$mount('#app');
```

在 `components` 目录下新建 `DataV.vue` 文件，输入代码内容：

```html
<template>
  <div>
    <div id="DataV" style="width:1000px;height: 300px">
      <!-- 引入边框组件 -->
      <dv-border-box-12>
        <div class="content">
          <!-- 添加动态环图 -->
          <dv-active-ring-chart
            :config="config"
            style="width:300px;height:300px"
          />
          <!-- 添加胶囊柱图 -->
          <dv-capsule-chart :config="config" style="width:300px;height:200px" />
          <!-- 添加水位图 -->
          <dv-water-level-pond
            :config="pond"
            style="width:150px;height:200px"
          />
        </div>
      </dv-border-box-12>
    </div>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        pond: {
          data: [66],
        },
        config: {
          data: [
            {
              name: '周口',
              value: 55,
            },
            {
              name: '南阳',
              value: 120,
            },
            {
              name: '西峡',
              value: 78,
            },
            {
              name: '驻马店',
              value: 66,
            },
            {
              name: '新乡',
              value: 80,
            },
          ],
        },
      };
    },
    methods: {},
  };
</script>

<style lang="scss" scoped>
  #DataV {
    padding: 20px;
    background-color: #282c34;
    border-radius: 10px;
    .content {
      display: flex;
      align-items: center;
      justify-content: space-around;
    }
  }
</style>
```

随后在 `App.vue` 文件中进行引入与注册：

```html
<template>
  <div id="app">
    <Chart />
    <DataV />
  </div>
</template>

<script>
  import Chart from './components/Chart.vue';
  import DataV from './components/DataV.vue';
  export default {
    name: 'App',
    data() {
      return {};
    },
    components: {
      Chart,
      DataV,
    },
  };
</script>

<style lang="scss">
  #app {
    display: flex;
    flex-wrap: wrap;
  }
</style>
```

使用如下命令运行项目。

```bash
npm run serve
```

编译好之后点击实验楼右侧选择列表中的 **Web 服务**，按钮查看界面效果：

![DataV 基本使用案例](https://doc.shiyanlou.com/courses/2824/1456545/6e0f09bfa4fb8ee562512c9d14a90954-0)

需要注意的是，DataV 组件中的数据需要使用对象进行传入，对象中的数据格式请参照官方文档中的格式进行编写。

如果想要在 DataV 中使用动态数据组件，写法稍微有些不同，由于 DataV 组件里的 props 均未设置 deep 监听，刷新 props 时需生成新的 props 对象（基础数据类型除外）来强制触发更新。除了生成新对象，也可以在完成赋值操作后，使用 ES6 拓展运算符（`this.someProps = { ...this.someProps }`）生成新的 props 对象来达到同样的效果。

我们使用数字翻牌器来作为动态修改数据的案例，在 `components` 目录下新建 `DynamicData.vue` 文件，输入代码内容：

```html
<template>
  <div>
    <div id="DynamicData" style="width:300px;height: 300px">
      <dv-border-box-10>
        <div class="content">
          <dv-digital-flop :config="config" />
        </div>
      </dv-border-box-10>
    </div>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        number: 100,
        config: {
          number: [100],
          toFixed: 2,
          content: '{nt}个',
        },
      };
    },
    mounted() {
      // 在生命周期中调用定时函数
      this.timingFn();
    },
    beforeDestroy() {
      // 在组件销毁的时候清除定时函数
      clearInterval(this.timeFn);
    },
    methods: {
      timingFn() {
        this.timeFn = setInterval(() => {
          // 每间隔 2S 就把数据 +1
          this.config.number[0] = ++this.number;
          // 强制进行更新
          this.config = { ...this.config };
        }, 2000);
      },
    },
  };
</script>

<style lang="scss" scoped>
  #DynamicData {
    margin: 20px;
    padding: 20px;
    background-color: #282c34;
    border-radius: 10px;
    .content {
      display: flex;
      align-items: center;
    }
  }
</style>
```

随后在 `App.vue` 文件中进行引入与注册：

```html
<template>
  <div id="app">
    <Chart />
    <DataV />
    <DynamicData />
  </div>
</template>

<script>
  import Chart from './components/Chart.vue';
  import DataV from './components/DataV.vue';
  import DynamicData from './components/DynamicData.vue';
  export default {
    name: 'App',
    data() {
      return {};
    },
    components: {
      Chart,
      DataV,
      DynamicData,
    },
  };
</script>

<style lang="scss">
  #app {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
  }
</style>
```

填写好代码后刷新界面，观察最新界面的效果。如果每间隔 2 秒数字组件进行滚动，表示数据成功更新。

![翻牌器案例](https://doc.shiyanlou.com/courses/2824/1456545/58cd9679750d16aa5e08da229ecc0733-0)

## Element UI

Element UI 是一套基于 Vue 2.0 的桌面端组件库，其中的很多组件可以帮助我们快速搭建页面，例如后续实验将要用到的 NavMenu 导航菜单、Table 表格、Breadcrumb 面包屑等。来跟随官方文档（[组件 | Element](https://element.eleme.cn/#/zh-CN/component/installation)）学习 Element UI 的安装和使用。

如图所示，可以看到生成的项目默认包含一些目录，下面来介绍几个重点目录和文件：

![10-20](https://doc.shiyanlou.com/courses/3472/1557563/cd1c0f29c98141de9b057463b44a1704-0/wm)

1. `node_modules`：存放项目的各种依赖。
2. `public`：存放静态资源，其中的 index.html 是项目的入口文件，浏览器访问项目的时候默认打开的是生成后的 index.html。
3. `src`：存放项目主体文件，具体介绍如下：
   - `assets`：存放各种静态文件，包括图片、CSS 文件、JavaScript 文件、各类数据文件等。
   - `components`：存放公共组件，比如此课程后续将会用到的顶部导航栏 Header.vue。
   - `router/index.js`：vue-router 安装时自动生成的路由相关文件，主要用来为每个路由设置路径、名称和对应页面的 .vue 文件等。
   - `store/index.js`：vuex 安装时自动生成的状态相关文件，后续章节会详细介绍，用来让多个页面或组件共享数据。
   - `views`：存放页面文件，比如默认生成的 Home.vue 首页、About.vue 关于页面。
   - `App.vue`：是主 vue 模块，主要是使用 router-link 引入其他模块，所有的页面都是在 App.vue 下切换的。
   - `main.js`：是入口文件，主要作用是初始化 vue 示例、引用某些组件库或挂载一些变量。
4. `.eslintrc`：配置代码校验 ESLint 规则。
5. `.gitignore`：配置 git 上传时想要忽略的文件。
6. `babel.config.js`：一个工具链，主要用于兼容低版本的浏览器。
7. `package.json`：配置项目名称、版本号，记录项目开发所安装的依赖的名称、版本号等。
8. `package-lock.json`：记录项目安装依赖时，各个依赖的具体来源和版本号。



### 引入

引入element-ui `npm install element-plus --save`

在`main.js`中引入

~~~
import ElementUI from 'element-plus'
import 'element-plus/dist/index.css'

createApp(App).use(store).use(router).use(ElementUI).mount('#app')
~~~

### 按钮

+ 增加按钮

~~~
<el-button type="primary">主要按钮</el-button>
~~~

改为圆形按钮

~~~
<el-button type="primary" round>主要按钮</el-button>
~~~

### input框

我们再来看下 Input 输入框的事件介绍：

![10-29](https://doc.shiyanlou.com/courses/3472/1557563/bfd6227e3c3c6de6198b48d0f40f2378-0)

可以看到 Element UI 提供了组件最常用的一些事件，包括事件名称、说明和回调参数的格式，比如输入框的失焦事件，继续向 `src/views/Home.vue` 文件中写入如下代码：`@blur`表示注册or触发某一事件

```html
<el-input v-model="testValue" placeholder="请输入内容" @blur="handleBlur" style="width: 200px;"></el-input>
<script>
// @ is an alias to /src
import HelloWorld from '@/components/HelloWorld.vue'

export default {
  name: 'Home',
  components: {
    HelloWorld
  },
  data() {
    return {
      testValue: '' //  输入框的值
    }
  },
  methods: {
    // 输入框失焦事件
    handleBlur() {
      console.log(this.testValue) //  控制台打印出输入框的值
    }
  }
}
</script>
```

![10-30](https://doc.shiyanlou.com/courses/3472/1557563/509332865627f502e657bbb9d81ada71-0)

在页面上的输入框中输入 `this is test value`，点击输入框之外的区域，触发输入框的失焦事件，可以看到控制台（F12 打开）打印出了输入框的值：

![10-31](https://doc.shiyanlou.com/courses/3472/1557563/2224767101d17d4968284bd5f2466ee6-0)

其他组件的使用，大家有兴趣可以自行学习和研究。

### 使用 Vue Router 添加路由

Vue Router 是 Vue.js 官方的路由管理器（[Vue Router](https://router.vuejs.org/zh/)），和 Vue.js 的核心深度集成，可以帮我们快速创建、配置路由，例如路由和页面的对应、路由参数获取和修改、HTML5 历史模式或 hash 模式等。

先来看下自动生成的路由文件 `src/router/index.js`，首先需要引入 `vue-router` 模块（在上个实验中创建项目时，已经安装了 Vue Router 依赖）、挂载在 Vue 上，接着需要创建路由列表，包含路径、路由名称、页面文件等配置，之后创建路由实例，并导出，然后在 `src/main.js` 中引入并使用即可。

![11-1](https://doc.shiyanlou.com/courses/3472/1557563/86571992803593a744e16c9f8d0f08bc-0)

基于上一个实验，对此文件中的部分代码做了注释说明：

```javascript
import Vue from 'vue'
import VueRouter from 'vue-router' //  引入vue-router模块
import Home from '../views/Home.vue' //  引入Home页面对应的文件

Vue.use(VueRouter) //  将VueRouter挂载在Vue上

// 创建路由列表
const routes = [
  {
    path: '/', //  路由路径，即浏览器地址栏中显示的URL
    name: 'Home', //  路由名称
    component: Home //  路由所使用的页面
  },
  {
    path: '/about',
    name: 'About',
    /**
     * 1. route level code-splitting
     * 2. this generates a separate chunk (about.[hash].js) for this route :
     *    这会为该路由生成一个单独的块(about.[hash].js)，打包时对应的css文件、js文件将会以 webpackChunkName 的值拼接hash值命名。
     * 3. which is lazy-loaded when the route is visited.
     *    当此路由被加载时，才加载对应的页面文件。这样做可以加快页面访问速度。
     */
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  }
]

// 创建路由实例
const router = new VueRouter({
  mode: 'history', //  HTML5 History 模式
  base: process.env.BASE_URL,
  routes
})

export default router
```

这里特别要说明的是 HTML5 History 模式。如果不使用 history 模式，例如现有的关于页面，路由路径将会是 `http://oursite.com/#/about` 这种形式。如果不想要就很丑的 hash， 可以用路由的 **history 模式**，那么路由路径就会是 `http://oursite.com/about`。这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。如果使用了这种模式，在部署时需要后台配置支持，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/about` 就会返回 404。所以需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面。

例如此次课程部署用到的 nginx，应当添加如下配置：

```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

这里先暂做了解，后续实验将会在部署相关章节中，详细说明配置项。

之后，我们可以在 `*.vue` 文件中通过 `$router` 访问路由实例，调用 `this.$router` 来操作路由（[编程式的导航 | Vue Router](https://router.vuejs.org/zh/guide/essentials/navigation.html)），例如后续实验将会用到的 `this.$router.push`，用于向 history 栈添加新的记录；使用 `this.$route` 获取路由信息，例如接下来将会用到的获取当前页面路由路径 `this.$route.path`。

#### stylus

+ stylus和sass是一回事，都是渲染外观的

首先来做一点清洁工作：删除 `src/views/about.vue` 文件，删除 `src/router/index.js` 中的路由 About，在 `src/App.vue` 的<style>中，删除`text-align center`、`color #2c3e50`、`margin-top 60px`。

在 `src/assets` 下新建 `style` 文件夹，然后在该文件夹下新建 `base.styl` 文件，键入以下内容，设置所有元素的外边距和内边距均为 `0px`：

```stylus
* {
  margin: 0;
  padding: 0;
}
```

然后在 `src/main.js` 中引入此样式文件：

```javascript
import './assets/style/base.styl'
```

+ puzzle

~~~
./src/main.js
Module not found: Error: Can't resolve 'stylus-loader' in 'D:\dev\code\Vue\vue-alg-analyze'
Failed to resolve loader: stylus-loader
You may need to install it.
~~~

因为没有安装stylus和stylus-loader

~~~
npm install stylus --save
npm install stylus-loader --save
~~~

安装失败可能是package.json里面没有写版本号。



#### sass

这部分用sass代替

App.vue中添加scss信息

~~~~
<style lang="scss">
  @import './assets/style/style.scss';
</style>
~~~~

在`./assets/style/style.scss`路径写入渲染信息。



#### 路由配置

我们将沿用 `src/router/index.js` 中的路由 Home 来作为首页，可以看到此路由的 component 中引入的页面文件为 `src/views/Home.vue`，先来清空下 `src/views/Home.vue` 中的代码，以便进行后续的代码编写，并删除 `src/components/HelloWorld.vue` 文件。

清空后，键入以下内容：

```
<template>
  <div class="home">这是网盘主页</div>
</template>

<script>
export default {
  name: 'Home',
  data() {
    return {}
  },
  methods: {}
}
</script>
```

在 `src/views` 中新建登录页面文件 `Login.vue`，键入以下内容：

```
<template>
  <div class="login">这是登录页面</div>
</template>

<script>
export default {
  name: 'Login',
  data() {
    return {}
  },
  methods: {}
}
</script>
```

在 `src/router/index.js` 创建登录页面路由：

```javascript
const routes = [
  ...
  {
    path: '/login', //  登录页面
    name: 'Login',
    component: () => import(/* webpackChunkName: "login" */ '../views/Login.vue')
  }
]
```

同理，在 `views` 目录下新建注册页面文件 `Register.vue` 并添加路由：

```
<template>
  <div class="login">这是注册页面</div>
</template>

<script>
export default {
  name: 'Login',
  data() {
    return {}
  },
  methods: {}
}
</script>
```

在 `router/index.js` 文件下添加路由：

```javascript
const routes = [
  ...
  {
    path: '/register', //  注册页面
    name: 'Register',
    component: () => import(/* webpackChunkName: "register" */ '../views/Register.vue')
  }
]
```

页面和路由添加好了，我们需要在 `src/App.vue` 中添加上述三个页面的跳转链接。

#### 跳转链接添加

在 `src/App.vue` 中的 <template> 中添加首页、登录、注册页面的跳转链接：

```
<template>
  <div id="app">
    <div id="nav">
      <router-link to="/">首页</router-link> | <router-link to="/login">登录页面</router-link> |
      <router-link to="/register">注册页面</router-link>
    </div>
    <router-view />
  </div>
</template>
```

现在启动项目：（之后将不再提示）

```bash
cd file-web
npm run serve
```

启动成功之后，仍然是点击右侧的 Web 服务（之后将不再提示）打开页面，检验下上述三个页面是否可以显示并成功跳转：

首页页面及路径：

![11-2](https://doc.shiyanlou.com/courses/3472/1557563/0c9454b3417ec27cd3f5c74254cdc076-0/wm)

登录页面及路径：

![11-3](https://doc.shiyanlou.com/courses/3472/1557563/371b16f3d40b2fbd12b3b4a13ef61e99-0/wm)

注册页面及路径：

![11-4](https://doc.shiyanlou.com/courses/3472/1557563/8914914fa600c0c4c55a7e8ed55a35f2-0/wm)

可以看到三个页面均可以成功跳转。

#### 404页面添加

为了防止用户在地址栏输入错误的路径而导致页面加载出错，我们需要用一个 404 页面来拦截，页面添加方式与登录、注册页面相同，在 `src/views` 目录下新建 `Error_404.vue` 文件：

```
<template>
  <div class="error-404">此页面不存在……</div>
</template>

<script>
export default {
  name: 'Error_404'
}
</script>
```

重点是 404 页面路由的添加位置，需要添加在所有路由之后（[404 Not found 路由](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#捕获所有路由或-404-not-found-路由)）：

```javascript
const routes = [
  ...
  {
    path: '/register', //  注册页面
    name: 'Register',
    component: () => import(/* webpackChunkName: "register" */ '../views/Register.vue')
  },
  {
    path: '/:pathMatch(.*)*', //  404页面
    name: 'Error_404',
    component: () => import(/* webpackChunkName: "error_404" */ '../views/Error_404.vue')
  }
]
```

可以看到在浏览器地址栏里输入不存在的路径，就会自动打开 404 页面，有 CSS 基础的同学，可以给 404 页面添加一些样式，或者去 Iconfont（[阿里巴巴矢量图标库](https://www.iconfont.cn/home/index)）上寻找一些图标或插画，来使页面内容更加丰富。

![11-5](https://doc.shiyanlou.com/courses/3472/1557563/a19fcda53e85b2645d5416c237bf8608-0/wm)

#### 使用 Element UI 中的 NavMenu 导航菜单

前面我们已经成功的添加了页面，接下来我们将使用 [NavMenu 导航菜单](https://element.eleme.cn/#/zh-CN/component/menu) 添加顶部导航栏，帮助我们快速构建页面，免去不必要的样式修改、事件添加等工作。

在 `src/components` 下创建文件 `Header.vue`，键入以下内容：

```
<template>
  <el-menu :default-active="activeIndex" :router="true" mode="horizontal">
    <el-menu-item index="Home" :route="{ name: 'Home' }">首页</el-menu-item>
    <el-menu-item index="Login" :route="{ name: 'Login' }">登录</el-menu-item>
    <el-menu-item index="Register" :route="{ name: 'Register' }">注册</el-menu-item>
  </el-menu>
</template>

<script>
export default {
  name: 'Header',
  data() {
    return {}
  },
  computed: {
    // 当前激活菜单的 index
    activeIndex() {
      return this.$route.name //  获取当前路由名称
    }
  }
}
</script>
```

其中的 el-menu 即为 Element UI 中的 NavMenu 导航菜单，`:router="true"` 表示使用 vue-router 的模式， index 是每个导航菜单的唯一标志，这里配置为各个页面对应的路由名称 name，default-active 为当前激活菜单的 index，为了刷新页面时也可以保证停留在当前页面，这里采用计算属性的方式给 activeIndex 赋值。<el-menu-item> 中的属性 route 为 Vue Router 路径对象，即要跳转到的页面的路由对象，这里依次配置为首页、登录、注册页面的路由对象。

在 `src/App.vue` 中引入、注册并使用此组件：

```
<template>
  <div id="app">
    <!-- 3. 使用组件 -->
    <Header></Header>
    <router-view />
  </div>
</template>

<script>
import Header from '@/components/Header.vue' //  1. 引入组件

export default {
  name: 'App',
  //  2. 注册组件
  components: {
    Header
  }
}
</script>
```

来看下页面效果：

![11-6](https://doc.shiyanlou.com/courses/3472/1557563/69f3034b991cab3b0b6b6faf92b8819b-0/wm) ![11-7](https://doc.shiyanlou.com/courses/3472/1557563/9d6ba7844f0e0c88ad2f411cc24bf732-0/wm) ![11-8](https://doc.shiyanlou.com/courses/3472/1557563/b6500c870def93beccbc5401d67c0bda-0/wm)

至此我们的顶部导航栏就实现了，最终的文件目录结构如下：

![11-9](https://doc.shiyanlou.com/courses/3472/1557563/ed801569722c303ede36097c8f0a00a2-0/wm)

有兴趣的同学可以自己参考官方文档给的组件属性，结合 stylus 调整下导航栏的样式，例如将登录、注册靠右放置、当前激活菜单底部高亮颜色修改等。

vue router [[安装 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/installation.html)](https://router.vuejs.org/zh/guide/advanced/meta.html)

#### 子路由

子路由需要在 [Vue](https://so.csdn.net/so/search?from=pc_blog_highlight&q=Vue)Router 的参数中使用 children 配置；

切记，在children 中，子路由的路径不要加 **/** ；

[Vue --- router，路由嵌套children的基本使用_LiuDevelop的博客-CSDN博客_vue 路由配置children](https://blog.csdn.net/qq_21980517/article/details/100073887)

path 和 name 看起来都是一样的值,对于[vue](https://so.csdn.net/so/search?from=pc_blog_highlight&q=vue)初学者来说确实烧脑，两个值看起来都一样，到底是用的name还是path传参的呢？

name和path都可以实现跳转：

一般情况下 **name和params**结合 **path和query**结合使用

[Vue中 path和name的区别是什么_m0_61726249的博客-CSDN博客_vue路由path与name的区别](https://blog.csdn.net/m0_61726249/article/details/121014904?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.opensearchhbase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.opensearchhbase)

一般是使用的path

`redirect`表示重定义

`meta`路由元信息[路由元信息 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/advanced/meta.html)

[vue 面包屑功能利用 vue-router meta属性简单实现 - 简书 (jianshu.com)](https://www.jianshu.com/p/efa6c7378963)

slot 其实就是能够让我们在父组件中添加内容到子组件的‘空间’

[彻底搞懂slot插槽，图文详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/9a7f8ab07bf8)







# 极客时间

## 05丨初识单文件组件

~~~
vue
|---node_modules	项目依赖文件夹
|---public
	index.html	项目载体，有`div`
	favicon.ico	图标
|---src		项目源代码
	main.js		入口文件
babel.config.js	babel文件
package.json	声明依赖
~~~

## 06丨Vue组件的核心概念(1)：属性

![image-20211215155031601](E:\Document\Typora\img\image-20211215155031601.png)

## 07丨Vue组件的核心概念(2)：事件

![image-20211215161635956](E:\Document\Typora\img\image-20211215161635956.png)



![image-20211213105344293](E:\Document\Typora\img\image-20211213105344293.png)



![image-20211213105612600](E:\Document\Typora\img\image-20211213105612600.png)

## 28丨UI组件库对比

+ Element UI、Ant Design Vue、iView)

![image-20211214094737187](E:\Document\Typora\img\image-20211214094737187.png)





# VideoAnalyzeClient创建

## 创建

~~~
vue create AlgAnalyzeWeb
~~~

报错：

~~~
Invalid project name: "AlgorithmAnalyzeWeb"
Warning: name can no longer contain capital letters
~~~

vue命令无法创建命名包含大写字母的项目

[VueCLI v4.5.4 创建vue项目（手选模式创建）_{竹子} -CSDN博客_vue项目](https://blog.csdn.net/u010411264/article/details/108431034)

1. 创建项目`vue create vue-alg-analyze`
2. 选择配置
3. 启动文件`npm run serve`

4. vue3引入element-ui `npm install element-plus --save`

在`main.js`中引入

~~~
import ElementUI from 'element-plus'
import 'element-plus/dist/index.css'

createApp(App).use(store).use(router).use(ElementUI).mount('#app')
~~~

### 代码使用

直接挪用部分`vue-admin-template`报错

1. `npm run lint --fix`查看编译报错。

错误：

1. `error :the $listener is deprecated`

[$listeners 被 Vue3 抛弃了，那它的活儿谁来接？ - 尹宇星_Kim - 博客园 (cnblogs.com)](https://www.cnblogs.com/yinyuxing/p/14558492.html)

2. error: `slot` attributes are deprecated

3. '.native' modifier on 'v-on' directive is deprecated 

不理解，抄`vue-element-template`直接转换的src-out



+ 安装vuex

~~~
 npm install vuex --save
~~~

报错

 输入npm info xxxx(插件名称) versions可查看当前插件所有版本

~~~
npm info vuex versions
~~~

`dependencies`添加`"vuex": "^4.0.2"`

+ 安装js-cookie

报错

~~~
These dependencies were not found:

* @/api/user in ./src/store/modules/user.js
* @/settings in ./src/store/modules/settings.js
* js-cookie in ./src/store/modules/app.js, ./src/utils/auth.js

To install them, you can run: npm install --save @/api/user @/settings js-cookie
~~~

安装js-cookie

~~~
npm install js-cookie --save
~~~

#### vuex使用

[Module | Vuex (vuejs.org)](https://next.vuex.vuejs.org/zh/guide/modules.html)

[Vue前端项目-首页-左侧菜单栏的展开与折叠_踏 浪的博客-CSDN博客_vue侧边栏展开和折叠原理](https://blog.csdn.net/u010559460/article/details/105235469)

理解代码的使用

`src\layout\components\Navbar.vue`的`@toggleClick="toggleSideBar"`触发`src\store\modules\app.js`的行为`toggleSideBar`，触发状态改`TOGGLE_SIDEBAR`，从而改变了状态。

js-cookie用来做缓存，vetur主要是整体状态数据的切换，比如store/modules/app.js



### 使用webpack引入layout

理解layout

~~~
layout
|---components
|---|---Sidebar
		FixOSBug.js
		index.vue
		Item.vue
		Link.vue
		Logo.vue
		SidebarItem.vue
	AppMain.vue
	index.js
	Navbar.vue
|---mixin
	ResizeHandler.js
index.vue
~~~





### 使用svg的icon

[手摸手，带你优雅的使用 icon - SegmentFault 思否](https://segmentfault.com/a/1190000012213278)





# vue-element-admin和vue-element的相互转换

## 安装依赖

注:`npm install -g xxx`全局安装，`npm install --save xxx`项目安装

查看适用的版本` npm view vuex versions `查看适合的版本。

安装指定版本的依赖包`npm install vuex@3.6.2`

临时设置淘宝镜像`npm --registry https://registry.npm.taobao.org install express`

```
–save           安装dependencies下的包，
–save-dev       安装devDependencies下的包
```

+ vue.config.js

根目录下自动加载。

~~~
publicPath: '/hello',
~~~

设置默认启动路径

[vue.config.js 配置_muzidigbig的博客-CSDN博客_vue.config.js配置](https://blog.csdn.net/muzidigbig/article/details/115665717)

+ 安装webpack使用的alies

这个本来想使用`vue init webpack project`的方法初始化安装，但是好像新版本这个方案已经被淘汰了，所以改为在vue create之后进行配置。

## webpack

+ 安装webpack
+ 配置全局文件`vue.config.js`打包`@`

~~~
configureWebpack: {
  // provide the app's title in webpack's name field, so that
  // it can be accessed in index.html to inject the correct title.
  name: name,
  resolve: {
    alias: {
      '@': resolve('src')
    }
  }
},		
~~~



## vuex

+ 安装vuex使用store存储全局数据
+ 项目中的mapGetters可以让非父子组件之间的数据通信得以实现

理解store的index.js

~~~
// 加载modules下的所有.js后缀的组件
const modulesFiles = require.context('./modules', true, /\.js$/)

const modules = modulesFiles.keys().reduce((modules, modulePath) => {
  const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
  const value = modulesFiles(modulePath)
  modules[moduleName] = value.default
  return modules
}, {})
~~~

[require.context()的用法详解_pinbolei的博客-CSDN博客](https://blog.csdn.net/pinbolei/article/details/115620728)

[对vue-element-admin后台开源框架的解读---vuex篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/379845451)

[js中的reduce()函数讲解_javascript技巧_脚本之家 (jb51.net)](https://www.jb51.net/article/154881.htm)

+ reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。

[vuex中store的action和mutations_zb0002011的博客-CSDN博客_store调用action](https://blog.csdn.net/zb0002011/article/details/108545523)



~~~
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

// 所有应用级别的状态都放在这里
const state = {
  // 计数器的初始状态为 0
  count: 0,
};

// 类似于组件中的 computed，可以对 state 里面的数据
// 做处理，然后通过 $store.getters.func 的方式获取
const getters = {};

// state 里面的状态不能直接改变，想要改变就需要在这里
// 定义函数，函数的第一个参数是 state，通过这个参数改
// 变 state 里面的数据
// 在组件中通过 $store.commit() 触发
const mutations = {};

// 和 mutations 类似，但 actions 触发的是 mutations
// mutations 只能进行同步操作，在 actions 中可以定义
// 异步操作
const actions = {};

export default new Vuex.Store({
  state,
  getters,
  mutations,
  actions,
});
~~~

+ 在store中定义`action`



## 理解路由和页面跳转

+ 参考

[权限验证 | vue-element-admin (panjiachen.github.io)](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html)

[手摸手，带你用vue撸后台 系列二(登录权限篇) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903478880370701)



+ 登录后存储用户信息

![image-20220601161445615](E:\Document\Typora\img\image-20220601161445615.png)



+ 权限登录

[手摸手，带你用vue撸后台 系列二(登录权限篇) - SegmentFault 思否](https://segmentfault.com/a/1190000009506097)

### premission.js引入作为router的初始页面跳转

+ 引入NProgress作为进度条
+ router.beforeEach((to, from, next)=>())

[动态路由下的导航守卫--（to,from,next）_笑道三千的博客-CSDN博客](https://blog.csdn.net/weixin_42349568/article/details/121438719)

[vue.js路由vue-router（二）——路由进阶 - SegmentFault 思否](https://segmentfault.com/a/1190000009425705)

+ 用stroe和cookie代替localStorage

`localStorage`是实现本地存储的方式。

+ `const { roles } = await store.dispatch('user/getInfo')`

await 用于等待一个异步任务执行完成的的结果。

await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行async function。若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。

+ 理解vuex中store的action和mutations

dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch('action方法名',值)

commit：同步操作，写法：this.$store.commit('mutations方法名',值)

## 登录界面

通过[通用组件—SvgIcon引入和使用_codfishXY的博客-CSDN博客_svgicon](https://blog.csdn.net/codfishXY/article/details/119170583)引入svg

el-form-item后接svg加入图标，但是不知道为什么会另起一行。找不到原因，直接就这样吧。

![image-20220607095834191](E:\Document\Typora\img\image-20220607095834191.png)

+ 与后端互联消息

1. 前者为vue-admin-template
2. 后者为实验楼代码

![image-20220608101105155](E:\Document\Typora\img\image-20220608101105155.png)

+ 跨域造成post消息变成options

### router的逻辑

flask的返回内容

![image-20220609091055730](E:\Document\Typora\img\image-20220609091055730.png)

会对应到

![image-20220609091133055](E:\Document\Typora\img\image-20220609091133055.png)





## Layout

[布局 | vue-element-admin (panjiachen.github.io)](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/layout.html#layout)

navbar包括了一下

![image-20220610150249993](E:\Document\Typora\img\image-20220610150249993.png)

其中HeaderSearch包含fuse，用于模糊查找。

rightPanel实际上是让整体界面左移，关于其sass

+ z-index属性是css中用于设置元素的堆叠顺序的一种属性
+ borde-radius 为元素圆角变框，一次为左上 右上 右下 左下
+ box-shadow  向 div 元素添加阴影：
+ transition 将鼠标悬停在一个 div 元素上，逐步改变表格的宽度从 100px 到 300px：
+ transform  属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。
+ pointer-events:  *属性*用于设置元素是否对鼠标事件做出反应
+ opacity: 指定了一个元素的透明度

## element-ui

+ 关于el-table的参数

header-cell-style：设置表头的样式

cell-style：设置表行的样式

函数动态改变样式

[vue table表格头部设置样式(header-cell-style/header-cell-class-name)_BiKABi的博客-CSDN博客_header-cell-style](https://blog.csdn.net/weixin_43932097/article/details/113513637)

[element UI表格使用cell-style改变单元格样式_huayang183的博客-CSDN博客_cell-style](https://blog.csdn.net/qq_18671415/article/details/106146077)

# vue-element-template学习指南

+ `npm run serve`报错

1. 先运行`npm install --registry=https://registry.npm.taobao.org`安装镜像
2. 再启动`npm run dev`

+ `vue-element-admin`太过复杂，先从`vue-element-template`入手

## 项目框架

~~~
├── build                      # 构建相关
├── mock                       # 项目mock 模拟数据，在接口服务器没有就绪时，临时充当接口
├── public                     # 静态资源
│   ├── favicon.ico            # favicon图标
│   └── index.html             # html模板
├── src                        # 源代码
│   ├── api                    # 所有请求
│   ├── assets                 # 主题 字体等静态资源  不会参与打包  直接直出
│   ├── components             # 全局公用组件 和业务不相关  上传组件
│   ├── icons                  # 项目所有 svg icons
│   ├── layout                 # 全局 layout 负责搭建项目的整体架子结构 html结构
│   ├── router                 # 路由
│   ├── store                  # 全局 store管理 vuex管理数据的位置 模块化开发 全局getters
│   ├── styles                 # 全局样式
│   ├── utils                  # 全局公用方法 request.js
│   ├── vendor                 # 公用vendor
│   ├── views                  # views 所有页面 路由级别的组件
│   ├── App.vue                # 入口页面 根组件
│   ├── main.js                # 入口文件 加载组件 初始化等
│   └── permission.js          # 权限管理
│   └── settings.js            # 配置文件
├── tests                      # 测试
├── .env.xxx                   # 环境变量配置
├── .eslintignore              # eslint 忽略文件
├── .eslintrc.js               # eslint 配置项
├── .gitignore                 # git 忽略文件
├── .travis.yml                # 自动化CI配置
├── .babel.config.js           # babel-loader 配置
├── jest.config.js             # 测试配置
├── vue.config.js              # vue-cli 配置
├── postcss.config.js          # postcss 配置
└── package.json               # package.json
~~~

![image-20211215095656141](E:\Document\Typora\img\image-20211215095656141.png)

##### **main.js**

main.js是整个项目的入口文件（webpack中学习的入口文件）

![image-20211215095807055](E:\Document\Typora\img\image-20211215095807055.png)

##### **App.vue**

App.vue是根组件

![image-20211215095822984](E:\Document\Typora\img\image-20211215095822984.png)

##### **permission.js** (先把内容注释掉)

**`permission.js`** 是控制页面登录权限的文件，在main.js中引入了它

![image-20211215095955008](E:\Document\Typora\img\image-20211215095955008.png)

此处的代码没有经历构建过程会很难理解， 所以先将此处的代码进行注释，等我们构建权限功能时，再从0到1进行构建

![permission.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5c2d0fbb7047c684158adf8b2ef1b8~tplv-k3u1fbpfcp-watermark.awebp)

##### settings.js

对于一些项目信息的配置，里面有三个属性 :

`title`(项目名称)

`fixedHeader`(固定头部)

`sidebarLogo`(显示左侧菜单logo), `settings.js`中的文件在其他的位置会引用到，我们不用动它

##### **Vuex**（把user.js内容注释掉）

当前的Vuex结构采用了模块形式进行管理共享状态，其架构如下

![vuex.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6069b6539194eb8a5f3e4aaeb5e49fe~tplv-k3u1fbpfcp-watermark.awebp)

其中app.js模块和settings.js模块，功能已经完备，不需要再进行修改 , user.js模块是我们后期需要重点开发的内容，所以这里我们将user.js里面的内容删除，并且导出一个默认配置

```
store/modules/user.js
export default {
  namespaced: true,
  state: {},
  mutations: {},
  actions: {}
}
复制代码
```

##### **scss**

> 该项目还使用了[scss](https://link.juejin.cn?target=https%3A%2F%2Fwww.sass.hk%2F)作为css的扩展语言，在`styles`目录下，我们可以发现scss的相关文件

##### **icons**

图标字体使用，icons的结构如下

![icon.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcea207ae6004996b91a317dab052816~tplv-k3u1fbpfcp-watermark.awebp)

## 代码修改

理解整体架构

![image-20211224102508434](E:\Document\Typora\img\image-20211224102508434.png)

### 修改格式

1. 修改登录界面，背景设置为动态视频vue-element-templete`src\views\login\index.vue`对应vue3项目的`src\views\user-manager\login\Index.vue`

2. 修改图标，把svg格式改成iconfront.

感觉改不了啊。。下面是svg格式图标引入修改的方法

[【Abp VNext】实战入门（五）：【13】前端管理界面 vue-element-admin —— 左侧菜单自定义图标及图标大小控制_刘永洪的博客-CSDN博客](https://blog.csdn.net/liuyonghong159632/article/details/114224640)

`src\components\SvgIcon\index.vue`的`.svg-icon`的宽高可以设置

~~~
.svg-icon {
  width: 1.4em;
  height: 1.4em;
~~~

+ 修改悬停时的颜色

关于svg的设置`src\components\SvgIcon\index.vue`

关于`variables.scss`对应的几个颜色`$menuHover;`对应的是悬停之后框的颜色

![image-20211224143323135](E:\Document\Typora\img\image-20211224143323135.png)

悬停时候的背景颜色在这修改，悬停时的字体颜色修改。

`variables.scss`增加悬停时候的字体颜色`menuHoverText`

`sidebar.scss`

![image-20211224144346983](E:\Document\Typora\img\image-20211224144346983.png)

## 升级项目代码版本vue2-->vue3

在文件`index.js`的`createRouter`增加

```
history: createWebHistory(process.env.BASE_URL)
```

+ 转代码

GoGoCode安装`npm install gogocode-cli -g`

代码升级`gogocode -s ./src -t gogocode-plugin-vue -0 ./src-out`

+ 依赖项修改

1. 在`package.json`文件修改版本号
2. 删除`node_modules`文件夹的原有依赖
3. `npm install`重新安装依赖

报错：

~~~
ERESOLVE
npm ERR! ERESOLVE could not resolve
npm ERR!
npm ERR! While resolving: vue-admin-template@4.4.0
npm ERR! Found: vue@2.6.10
npm ERR! node_modules/vue
npm ERR!   vue@"^3.0.0" from the root project
npm ERR!   peerOptional vue@"^2 || ^3.0.0-0" from @vue/babel-preset-app@4.5.15
npm ERR!   node_modules/@vue/babel-preset-app
npm ERR!     @vue/babel-preset-app@"^4.4.4" from @vue/cli-plugin-babel@4.4.4
npm ERR!     node_modules/@vue/cli-plugin-babel
npm ERR!       dev @vue/cli-plugin-babel@"4.4.4" from the root project
npm ERR!   3 more (@vue/test-utils, element-ui, vue-jest)
npm ERR!
npm ERR! Could not resolve dependency:
npm ERR! element-plus@"^1.2.0-beta.6" from the root project
npm ERR!
npm ERR! Conflicting peer dependency: vue@3.2.26
npm ERR! node_modules/vue
npm ERR!   peer vue@"^3.2.0" from element-plus@1.2.0-beta.6
npm ERR!   node_modules/element-plus
npm ERR!     element-plus@"^1.2.0-beta.6" from the root project
npm ERR!
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR!
npm ERR! See C:\Users\admin\AppData\Local\npm-cache\eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\admin\AppData\Local\npm-cache\_logs\2021-12-15T06_09_10_245Z-debug-0.log
~~~

感觉升级好麻烦啊，还不如自己重建算了，妈的心累。

# vue3-composition-admin-main

## 运行

+ 使用` npm run start`

为什么这个项目是用的ts不是js实现的啊，真的不理解，ts为动态的，js为静态的。

## 目录修改

+ 关于目录名修改

`src\locales\zh-cn.ts`存储了title和icon对应的实际信息

+ 关于图标替换

使用iconfront，自己建立一个iconfront项目。

使用的symbol方式

[iconfont Demo (alicdn.com)](https://at.alicdn.com/t/project/3023178/64f20ca6-a050-4fa9-8099-544dae5a3ae2.html?spm=a313x.7781069.1998910419.88)

`public\index.html`在线加载iconfront资源，修改`<script src=`

`src\assets\iconfont\iconfont.css`这个路径的width和height修改尺寸

## sidebar替换



+ sidebar的logo和文字替换

![image-20211217100249318](E:\Document\Typora\img\image-20211217100249318.png)

![image-20211217100544121](E:\Document\Typora\img\image-20211217100544121.png)

+ 对应代码的修改

`src\layout\components\side_bar\SidebarLogo.vue`修改位置

![image-20211217103744750](E:\Document\Typora\img\image-20211217103744750.png)

+ 测试sass的功能

margin 行间距

font-weight 字体厚度

line-height 段落的行高

font-size 字体大小

font-family

修改某一个字体

~~~
<h1 class="sidebar-title">
          智能<span style="color:#57CAEB">算法</span>平台
~~~

改字体

~~~
        <h1 class="sidebar-title">
          智能<span style="font-size:6px">算法</span>平台
~~~

这种格式不能同时修改两个的代码。

+ 拓展，理解side_bar

![image-20211217105209160](E:\Document\Typora\img\image-20211217105209160.png)

`SidebarItem`为下侧目录表，`SidebarLogo`为显示框。

## 国际化方案vue-i18n

[vue3中引入vue-i18n, 国际化方案_cwxblog的博客-CSDN博客_vue3 国际化](https://blog.csdn.net/cwxxiayi/article/details/115602088)



## 目录功能项代码修改

代码对应路径`[Edit Article - 1](http://localhost:9999/#/example/list)`

添加代码参考`src\router\permissionModules\example.ts`

文件导入可以参考excel的上传excel。





### dashboard代码逻辑

整体布局参考`src\views\dashboard\Index.vue`

`<GithubCorner class="github-corner" />`git corner挂件

![image-20211217140441344](E:\Document\Typora\img\image-20211217140441344.png)

#### 布局代码

elementUI的组件[组件 | Element](https://element.eleme.cn/#/zh-CN/component/layout)

**row 行概念**

```
<el-row></el-row>
```

**col 列概念**

```
<el-col></el-col>
```

**col组件的:span属性的布局调整,一共分为24栏:**

代码示例:

```
1 <el-row>
2   <el-col :span="24"><div class="grid-content"></div></el-col>
3 </el-row> 
```

效果展示:

![image-20211217140948442](E:\Document\Typora\img\image-20211217140948442.png)

 代码示例：

```
1 <el-row>
2   <el-col :span="12"><div class="grid-content"></div></el-col>
3 </el-row>
```

效果展示:

![image-20211217140958369](E:\Document\Typora\img\image-20211217140958369.png)

 `row组件的:gutter`属性来调整布局之间的宽度**---分栏间隔**

代码示例:

```
1 <el-row :gutter="20">
2   <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
3   <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
4 </el-row>
```

效果:

![image-20211217141017534](E:\Document\Typora\img\image-20211217141017534.png)

Col组件的`:offset`属性调整方块的偏移位置（每次1格/24格）

```
1 <el-row :gutter="20">
2   <el-col :span="6" :offset="6"><div class="grid-content"></div></el-col>
3   <el-col :span="6" :offset="6"><div class="grid-content"></div></el-col>
4 </el-row>
```

效果:

![image-20211217141030973](E:\Document\Typora\img\image-20211217141030973.png)

**对齐方式:**

**row组件的`type="flex"`启动flex布局，再通过row组件的`justify`属性调整排版方式，属性值分别有:**

1. justify=center 居中对齐
2. justify=start 左对齐
3. justify=end 右对齐
4. justify=space-between 空格间距在中间对齐
5. justify=space-around 左右各占半格空格对齐

```
1 <el-row type="flex" class="row-bg" justify="center">
2    <el-col :span="6"><div class="grid-content"></div></el-col>
3  </el-row>
```

效果:

![image-20211217141046193](E:\Document\Typora\img\image-20211217141046193.png)

**响应式布局:**

参考bootstrap的响应式，预设四个尺寸

1. xs <768px
2. sm ≥768px
3. md ≥992
4. lg ≥120

就是针对分辨率不一致的页面

```xml
<el-row :gutter="10">
  <el-col :xs="8" :sm="6" :md="4" :lg="3" :xl="1"><div class="grid-content bg-purple"></div></el-col>
  <el-col :xs="4" :sm="6" :md="8" :lg="9" :xl="11"><div class="grid-content bg-purple-light"></div></el-col>
  <el-col :xs="4" :sm="6" :md="8" :lg="9" :xl="11"><div class="grid-content bg-purple"></div></el-col>
  <el-col :xs="8" :sm="6" :md="4" :lg="3" :xl="1"><div class="grid-content bg-purple-light"></div></el-col>
</el-row>
```

**详解**
 其实就是做了每行总共24个栅格，在不同尺寸的页面上如何分配宽度比例：

| 名称 | 尺寸    |
| ---- | ------- |
| xs   | <768px  |
| sm   | ≥768px  |
| md   | ≥992px  |
| lg   | ≥1200px |
| xl   | ≥1920px |

比如这里直接给xs赋值4，他的宽度在xs（<768px，手机）就是4/24。
 除了直接给赋值数字，也可以给对象如：{span:18,offset:3}。
 span即是仅赋值数值时的默认参数位，为宽度。
 offset为从左边的偏移量，也是1/24为单位。

立刻搞定之前想要的效果：宽屏页面时内容仅仅占页面宽50%居中显示。窄屏幕时占70%，手机时占100%。



```xml
    <el-row :gutter="10">
      <el-col :xs="{span:24,offset:0}" :sm="{span:16,offset:4}" :md="{span:12,offset:6}">
      </el-col>
    </el-row>
```

gutter就是各col之间的间距。
 这种方法其实使用的还是@media。但是确实方便配置多了。



#### 整体构架

~~~
AdminDashboard
|---GithubCorner  :右上角github图标
|---PanelGroup    ：四个图标
|---LineChart	  ：曲线图
|---RadarChart	  :
|---PieChart
|---BarChart
|---DependsTable
|---TodoList
|---UpdateTimeline
|---BoxCard
EditorDashboard
~~~

![image-20211217150751785](E:\Document\Typora\img\image-20211217150751785.png)

## router

[《vue3+ts+element-plus 后台管理系统系列三》之路由侧边栏 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1790472)

有两个文件夹

~~~
// 自定义组件
const constantFiles = require.context('./constantModules', true, /\.ts$/)
let constantModules: Array<RouteRecordRaw> = []
// 遍历出每个组件的路径
constantFiles.keys().forEach((key) => {
  if (key === './index.ts') return
  constantModules = constantModules.concat(constantFiles(key).default)
})
~~~

+ 在首页之前先登录的逻辑

![image-20220524102639539](E:\Document\Typora\img\image-20220524102639539.png)



# Vue2.0+3.0最强全家桶教程

![image-20220520140714609](E:\Document\Typora\img\image-20220520140714609.png)

![image-20220520140210961](E:\Document\Typora\img\image-20220520140210961.png)

![image-20220520140650759](E:\Document\Typora\img\image-20220520140650759.png)

toUpperCase()为转为大写

# Vue3全套教程Web前端

+ ts和js，ts为js的超集

![image-20220520095700963](E:\Document\Typora\img\image-20220520095700963.png)

+ ts安装

~~~
npm install -g typescipt
~~~

+ 

# 前后端分离项目

## 安装依赖

+ 安装ElementUI



## Axios接口封装

Axios（[axios 中文网|axios API 中文文档 | axios](http://www.axios-js.com/)）是易用、简洁且高效的 http 库， 使用 Promise 管理异步，支持请求和响应拦截器，自动转换 JSON 数据等高级配置，与 Vue.js 有很好的融合。

### 基础设置

在 `http.js` 中先来引入 Axios，设置请求超时时间，基础 URL，并自定义 POST 请求头：

```javascript
import axios from 'axios'

// 请求超时时间
axios.defaults.timeout = 10000 * 5
// 请求基础URL，对应后台服务接口地址
axios.defaults.baseURL = 'http://localhost:8081'
// 自定义post请求头
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'
```

设置请求拦截器和响应拦截器，对接口的请求头、响应结果做统一处理，例如自定义请求头，对接口响应的 HTTP 状态码非 200 的情况做处理等：

```javascript
import { Message } from 'element-ui'

// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    //    自定义请求头
    return config
  },
  (error) => {
    //    请求错误时
    console.log(error) //    打印错误信息
    return Promise.reject(error)
  }
)

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    if (response.status === 200) {
      //    接口HTTP状态码为200时
      return Promise.resolve(response)
    }
  },
  // HTTP状态码非200的情况
  (error) => {
    if (error.response.status) {
      switch (error.response.status) {
        case 500: //    HTTP状态码500
          Message.error('后台服务发生错误')
          break
        case 401: //    HTTP状态码401
          Message.error('无权限')
          break
        case 404: //    HTTP状态码404
          Message.error('当前接口不存在')
          break
        default:
          this.$message.error(error.response.message) //    页面显示接口返回的错误信息
          return Promise.reject(error.response)
      }
    }
  }
)
```

### GET、POST、PUT、DELETE 接口类型封装

et 请求中的参数分为 params 和 info，其中 params 是查询参数，接口中的表现形式为 & 符号链接的 key=value 形式的字符串，统一用?符号拼接在接口后，例如常用的分页查询接口 `getFileList?page=1&pageSize=10`；info 参数直接拼接在 url 中，例如某些查询接口 get 请求，需要把 id 拼接在 url 中。

```javascript
/**
 * get方法，对应get请求
 */
export function get(url, params, info = '') {
  return new Promise((resolve, reject) => {
    axios
      .get(url + info, {
        params: params
      })
      .then((res) => {
        resolve(res.data) //    返回接口响应结果
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

post 请求中的参数分为 formData 格式和 json 格式，需要根据后台接口采用不同的传参格式：

```javascript
/**
 * post方法，对应post请求
 * info为 true，formData格式；
 * info为 undefined或false，是json格式
 */
export function post(url, data = {}, info) {
  return new Promise((resolve, reject) => {
    let newData = data
    if (info) {
      //  转formData格式
      newData = new FormData()
      for (let i in data) {
        newData.append(i, data[i])
      }
    }
    axios
      .post(url, newData)
      .then((res) => {
        resolve(res.data)
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

put 请求和 delete 请求封装同理：

```javascript
/**
 * 封装put请求
 */

export function put(url, params = {}, info = '') {
  return new Promise((resolve, reject) => {
    axios.put(url + info, params).then(
      (res) => {
        resolve(res.data)
      },
      (err) => {
        reject(err.data)
      }
    )
  })
}

/**
 * 封装delete请求
 */
export function axiosDelete(url, params = {}, info = '') {
  return new Promise((resolve, reject) => {
    axios
      .delete(url + info, {
        params: params
      })
      .then((res) => {
        resolve(res.data)
      })
      .catch((err) => {
        reject(err.data)
      })
  })
}
```

### 注册、登录接口封装

在 `src/request` 下创建新文件 `user.js`，所有与用户相关的接口均维护在这个文件中。

首先引入封装好的 get、post 类型的请求：

```javascript
import { get, post } from './http'
```

接下来封装登录接口：

- export 表示导出此接口，以便后续在 vue 文件中引入此接口去调用；
- const login 表示定义当前接口名称为 login，p 表示接口传参，对应刚才封装 get 类型请求时的 params，如果还需要传参 info，传参应当为(p, info)；
- get 表示接口类型为 get，`'/user/login'`为后台提供的接口 path。

```javascript
// 登录接口
export const login = (p) => get('/user/login', p)
```

封装注册接口：

```javascript
// 注册接口
export const addUser = (p) => post('/user/register', p)
```

### 后台项目启动

后台项目的编写可以参考本次课程的后台项目相关的实验，这里仅仅介绍后台项目启动，和如何连接后台接口。

在 `qiwen-file/src/main/resources/application.properties` 中第 1 行添加 `server.port=8081` 来修改后台服务启动端口：

```properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/file?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true
...
```

新建终端启动项目：

```bash
sudo service mysql start
cd /home/project/qiwen-file
mvn spring-boot:run
```

当出现以下结果，说明后台项目启动成功：

![12-1](https://doc.shiyanlou.com/courses/3472/1557563/b7fd02ff5506f52596327dcfe5da77a6-0)

### 接口连接

我们需要对 Axios 中的设置和封装做些改动，以便在本地开发环境中也可以调用接口。

在 `public` 中新建 `config.json` 文件，存放后台接口，这里必须配置完整的接口 baseURL，包括协议、IP、端口，有时候后台会有后缀 `/backend` 等：

```json
{
  "baseUrl": "http://localhost:8081"
}
```

在 `vue.config.js` 中配置代理：

```javascript
const productConfig = require('./public/config.json') // 引入config.json文件
module.exports = {
  publicPath: '/',
  devServer: {
    host: '0.0.0.0',
    open: true,
    disableHostCheck: true,
    proxy: {
      //配置代理，解决跨域请求后台数据的问题
      '/api': {
        target: productConfig.baseUrl, //后台接口，连接本地服务
        ws: true, //是否跨域
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/'
        }
      }
    }
  }
}
```

对 `src/request/http.js` 中的 Axios 的 baseURL 做修改：

```javascript
// 请求基础URL
axios.defaults.baseURL = '/api'
```

现在我们重新启动项目。

### 注册页面编写

先来采用 Element UI 的表单 Form 组件等编写页面，在 `src/views/Register.vue` 中键入以下内容：

```
<template>
  <div class="registerWrapper" id="registerBackground">
    <div class="formWrapper">
      <h1 class="registerTitle">注册</h1>
      <el-form
        :model="ruleForm"
        :rules="rules"
        ref="ruleForm"
        label-width="100px"
        class="demo-ruleForm"
        hide-required-asterisk
      >
        <el-form-item prop="username">
          <el-input
            prefix-icon="el-icon-user"
            v-model="ruleForm.username"
            placeholder="用户名"
          ></el-input>
        </el-form-item>
        <el-form-item prop="telephone">
          <el-input
            prefix-icon="el-icon-mobile-phone"
            v-model="ruleForm.telephone"
            placeholder="手机号"
          ></el-input>
        </el-form-item>
        <el-form-item prop="password">
          <el-input
            prefix-icon="el-icon-lock"
            v-model="ruleForm.password"
            placeholder="密码"
            show-password
          ></el-input>
        </el-form-item>
        <el-form-item class="registerButtonWrapper">
          <el-button
            class="registerButton"
            type="primary"
            @click="submitForm('ruleForm')"
            >注册</el-button
          >
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script>
export default {
  name: "Register",
  data() {
    return {
      ruleForm: {
        username: '',
        telephone: '',
        password: '',
      },
      rules: {
        username: [
          { required: true, message: "请输入用户名", trigger: "blur" },
        ],
        password: [
          { required: true, message: "请输入密码", trigger: "blur" },
          {
            min: 5,
            max: 20,
            message: "长度在 5 到 20 个字符",
            trigger: "blur",
          },
        ],
        telephone: [
          { required: true, message: "请输入手机号", trigger: "blur" },
          { min: 11, max: 11, message: "请输入11位手机号", trigger: "blur" },
        ],
      },
    };
  },
  methods: {
    //  注册按钮-点击事件
    submitForm() {},
  },
};
</script>

<style lang="stylus" scoped>
.registerWrapper {
  height: 500px !important;
  min-height: 500px !important;
  width: 100% !important;
  padding-top: 50px;

  .formWrapper {
    width: 375px;
    margin: 0 auto;
    text-align: center;

    .registerTitle {
      margin-bottom: 10px;
      font-weight: 300;
      font-size: 30px;
      color: #000;
    }

    .demo-ruleForm {
      width: 100%;
      margin-top: 20px;

      >>> .el-form-item__content {
        margin-left: 0 !important;
      }

      &>>> .el-input__inner {
        font-size: 16px;
      }

      .registerButtonWrapper {
        .registerButton {
          width: 100%;
        }

        &>>> .el-button {
          padding: 10px 90px;
          font-size: 16px;
        }
      }
    }

    .tip {
      width: 70%;
      margin-left: 86px;
    }
  }
}
</style>
```

看下页面效果：

![图片描述](https://doc.shiyanlou.com/courses/3472/1557563/1d4ff9263d586a351348da2ed96ad03d-0/wm)

### 注册接口使用

继续编辑 `Register.vue` 文件，引入封装好的注册接口：

```javascript
import { addUser } from '@/request/user.js'
```

在注册按钮的点击事件中调用注册接口：

```
<script>
import { addUser } from '@/request/user.js' //    引入注册接口

export default {
  name: 'Register',
  data() {
    return {
      // ……
    }
  },
  methods: {
    //  注册按钮-点击事件
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        //    校验表单
        if (valid) {
          //  各项校验通过-调用注册接口，传参用户名、手机号和密码
          addUser(this.ruleForm).then((res) => {
            if (res.success) {
              this.$notify({
                title: '成功',
                message: '注册成功！已跳转到登录页面',
                type: 'success'
              })
              this.$refs[formName].resetFields() // 注册成功之后清空表单
              this.$router.replace({ path: '/login' }) // 注册成功之后跳转到登录页面
            } else {
              this.$message.error(res.message) //  显示接口返回的错误信息
            }
          })
        } else {
          // 表单校验没通过
          this.$message.error('请完善信息！')
          return false
        }
      })
    }
  }
}
</script>
```

来看下接口调用是否符合代码中的处理：

![12-3](https://doc.shiyanlou.com/courses/3472/1557563/8b90bda3fec2cf8fd95f99a494e50580-0)

注册接口返回值中的 success 为 true 时：

![12-4](https://doc.shiyanlou.com/courses/3472/1557563/be2988673e8e8fbfcee75523feb99a34-0/wm)

注册接口的返回值中 success 为 false 时：

![12-5](https://doc.shiyanlou.com/courses/3472/1557563/ba62fe303251968011c72a15effb9888-0)

### 登录页面编写

在 `src/views/Login.vue` 中编写登录页面：

```
<template>
  <div class="loginWrapper" id="loginBackground">
    <div class="formWrapper">
      <h1 class="loginTitle">登录</h1>
      <el-form
        :model="ruleForm"
        :rules="rules"
        ref="ruleForm"
        label-width="100px"
        class="demo-ruleForm"
        hide-required-asterisk
      >
        <el-form-item prop="telephone">
          <el-input
            prefix-icon="el-icon-mobile-phone"
            v-model="ruleForm.telephone"
            placeholder="手机号"
          ></el-input>
        </el-form-item>
        <el-form-item prop="password">
          <el-input
            prefix-icon="el-icon-lock"
            v-model="ruleForm.password"
            placeholder="密码"
            show-password
          ></el-input>
        </el-form-item>
        <el-form-item class="loginButtonWrapper">
          <el-button
            class="loginButton"
            type="primary"
            @click="submitForm('ruleForm')"
          >
            登录
          </el-button>
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script>
export default {
  name: 'Login',
  data() {
    return {
      ruleForm: {
        telephone: '',
        password: ''
      },
      rules: {
        telephone: [{ required: true, message: '请输入手机号', trigger: 'blur' }],
        password: [
          { required: true, message: '请输入密码', trigger: 'blur' },
          { min: 5, max: 20, message: '长度在 5 到 20 个字符', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    //  登录按钮-点击事件
    submitForm() {}
  }
}
</script>

<style lang="stylus" scoped>
.loginWrapper {
  height: 550px !important;
  min-height: 550px !important;
  padding-top: 50px;

  .formWrapper {
    width: 375px;
    margin: 0 auto;
    text-align: center;

    .loginTitle {
      margin-bottom: 10px;
      font-weight: 300;
      font-size: 30px;
      color: #000;
    }

    .demo-ruleForm {
      width: 100%;
      margin-top: 20px;

      >>> .el-form-item__content {
        margin-left: 0 !important;
      }

      &>>> .el-input__inner {
        font-size: 16px;
      }

      .forgetPassword {
        text-align: right;
        margin: -22px 0 0 0;
      }

      .loginButtonWrapper {
        .loginButton {
          width: 100%;
        }

        &>>> .el-button {
          padding: 10px 90px;
          font-size: 16px;
        }
      }
    }

    .tip {
      width: 70%;
      margin-left: 86px;
    }
  }
}
</style>
```

### 登录接口使用

在登录按钮的点击事件中调用登录接口，这里我们需要在登录之后在接口的自定义请求头中添加 token。

键入以下命令安装 `js-cookie`：

```bash
npm install js-cookie
```

在 `src/request/http.js` 和 `src/views/Login.vue` 中引入 `js-cookie`，并自定义请求头：

`http.js` 中使用 `js-cookie`：

```javascript
import Cookies from 'js-cookie'

// 请求拦截器
axios.interceptors.request.use(
  (config) => {
    //    自定义请求头
    config.headers['token'] = Cookies.get('token')
    return config
  },
  (error) => {
    console.log(error)
    return Promise.reject(error)
  }
)
```

登录页面使用 `js-cookie`，引入封装好的登录接口，编辑 `src/views/Login.vue` 文件：

```
...
<script>
import { login } from '@/request/user.js'    //    引入登录接口
import Cookies from 'js-cookie'

export default {
  name: 'Login',
  data() {
    return {
      // ......
    }
  },
  methods: {
    //  登录按钮-点击事件
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          // 各项校验通过-调用登录接口
          login(this.ruleForm, true).then((res) => {
            if (res.success) {
              Cookies.set('token', res.data.token) //    在cookies中添加token
              this.$message.success('登录成功！')
              this.$refs[formName].resetFields() //    清空表单项
              this.$router.replace({ name: 'Home' }) // 跳转到首页
            } else {
              this.$message.error('手机号或密码错误！')
            }
          })
        } else {
          this.$message.error('请完善信息！')
          return false
        }
      })
    }
  }
}
</script>
```

使用刚才注册的用户，来测试下登录接口：

![12-6](https://doc.shiyanlou.com/courses/3472/1557563/006e7e0c3cee644eada6bbabb5198014-0)

![12-7](https://doc.shiyanlou.com/courses/3472/1557563/8b524482dcbedf8cb1dee61d2d2f75e2-0)

### 登录状态共享和页面跳转

在登录之后，需要保存登录状态，之后自动跳转到首页。若用户直接进入了首页，就需要自动跳转到登录页面，若用户已登录，进入登录和注册页面时，就需要自动跳转到首页。那么需要把登录状态共享给各个页面，就需要用到 Vue Router 的全局前置守卫（[导航守卫 | Vue Router](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫)）和 Vuex，关于 Vuex 的知识将会在下个实验介绍，这次实验先来实现状态共享和界面自动跳转。

### 登录状态保存

在 `src/request/user.js` 中添加获取用户登录信息接口：

```javascript
// 获取登录状态及用户信息
export const checkUserLoginInfo = (p) => get('/user/checkuserlogininfo', p)
```

先来使用 Vuex 把状态保存实现，在 `src/store` 下新建文件夹 `module`，并新建文件 `src/store/module/user.js`，键入以下内容（下节实验会介绍 Vuex 的使用）：

```javascript
import { checkUserLoginInfo } from '@/request/user.js' // 引入获取用户登录信息接口

export default {
  state: {
    isLogin: false, // 初始时候给一个 isLogin = false 表示用户未登录
    username: '',
    userId: 0,
    userImgUrl: '',
    userInfoObj: {}
  },
  mutations: {
    changeLogin(state, data) {
      state.isLogin = data
    },
    changeUsername(state, data) {
      state.username = data
    },
    changeUserId(state, data) {
      state.userId = data
    },
    changeUserInfoObj(state, data) {
      state.userInfoObj = Object.assign({}, state.userInfoObj, data)
    }
  },
  actions: {
    getUserInfo(context) {
      return checkUserLoginInfo().then((res) => {
        if (res.success) {
          context.commit('changeLogin', res.success)
          context.commit('changeUsername', res.data.username)
          context.commit('changeUserId', res.data.userId)
          context.commit('changeUserInfoObj', res.data)
        } else {
          context.commit('changeLogin', res.success)
        }
      })
    }
  }
}
```

在 `src/store/index.js` 中引入刚才创建好的 `user.js`，并将相关数据导出：

```javascript
import Vue from 'vue'
import Vuex from 'vuex'

import user from './module/user' // 引入user.js

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    //
  },
  getters: {
    isLogin: (state) => state.user.isLogin,
    username: (state) => state.user.username,
    userId: (state) => state.user.userId,
    userInfoObj: (state) => state.user.userInfoObj
  },
  mutations: {
    //
  },
  actions: {
    //
  },
  modules: {
    user
  }
})
```

之后就可以在 `*.vue` 文件中使用 `this.$store.getters.isLogin` 来获取用户的登录状态了。

### 全局前置守卫

为了判断哪些路由需要登录之后才可进入，需要在路由上添加一些信息。在 `src/router/index.js` 中给首页路由添加 meta 属性，并添加参数 `requireAuth`，值为 true：

```javascript
{
    path: '/',  //  路由路径，即浏览器地址栏中显示的URL
    name: 'Home', //  路由名称
    component: Home, //  路由所使用的页面
    meta: {
      requireAuth: true
    }
}
```

在 `src/router` 下新建文件 `before.js`，引入 Vue Router 和状态保存文件 `src/store/index.js`：

```javascript
import router from './index.js'
import store from '@/store/index.js'

// 路由全局前置守卫
router.beforeEach((to, from, next) => {
  // 调用接口，判断当前登录状态
  store.dispatch("getUserInfo").then(() => {
    if (to.matched.some(m => m.meta.requireAuth)) {
      if (!store.getters.isLogin) { // 没有登录    
        next({
          path: '/login',
          query: { Rurl: to.fullPath }
        })
      } else {
        next()   // 正常跳转到你设置好的页面 
      }
    } else {
      next()  // 正常跳转到你设置好的页面 
    }
  })
})
```

添加全局前置守卫，可以在触发导航之前进行一些处理，当处理完成后才会执行导航：

1. 先调用接口，判断当前登录状态。
2. 判断将要去的路由是否需要登录，即刚才我们给路由添加的参数 `meta.requireAuth` 是否为 true，若为 true，表示需要登录后才可进入；若没有设置当前参数，或参数值为 false，表示无需登录也可进入。
3. 当 `meta.requireAuth` 为 true 时，判断在 Vuex 中保存的 isLogin 为 true 还是 false，为 true 表示已登录，那么执行 `next()` 即可正常导航；为 false 表示未登录，按照之前的说明，将跳转到登录页面。

全局前置守卫有三个参数 to、from、next：

1. `to: Route`：即将要进入的路由对象，包含路由名称、路径、参数等。
2. `from: Route`：当前导航正要离开的路由对象。
3. `next: Function`：在全局前置守卫中， 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next` 方法的调用参数：`next()`无参数时， 进行管道中的下一个钩子；`next(false)` 参数为 false 时，中断当前的导航；`next({ path: '/' })` 跳转到一个不同的地址，当前的导航被中断，然后进行一个新的导航。 `next`支持传递任意位置对象，且允许设置诸如 `replace: true`、`name: 'home'` 之类的选项以及任何用[`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。

在 `src/main.js` 中引入刚才创建好的 `before.js`：

```javascript
import '@/router/before.js'
```

现在我们来直接进入首页，发现接口请求返回的 false，页面直接跳转到了登录页面，并且带了查询参数 `Rurl`：

![12-8](https://doc.shiyanlou.com/courses/3472/1557563/5e30c3525c906735cd097327dfd9821c-0)

然后来给登录、注册页面在登录状态下添加自动跳转到首页的效果，在 `src/views/Login.vue` 中的生命周期 `created()` 中添加登录状态判断：

```javascript
<script>
import { login } from '@/request/user.js'    //    引入登录接口
import Cookies from 'js-cookie'

export default {
  name: 'Login',
  data() {
    return {
      // ......
    }
  },
  created() {
    if (this.$store.getters.isLogin) {
      // 用户若已登录，自动跳转到首页
      this.$notify({
          title: '成功',
          message: '您已登录！已跳转到首页',
          type: 'success'
      })
      this.$router.replace({ name: 'Home' })
    }
  },
  methods: {
    ...
```

注册页面同理，在 `created` 中添加同样的处理。修改 `Register.vue` 文件，添加如下代码：

```
<script>
import { addUser } from '@/request/user.js' //    引入注册接口

export default {
  name: 'Register',
  data() {
    return {
      // ......
    }
  },
  created() {
    if (this.$store.getters.isLogin) {
      // 用户若已登录，自动跳转到首页
      this.$notify({
        title: '成功',
        message: '您已登录！已跳转到首页',
        type: 'success'
      })
      this.$router.replace({ name: 'Home' })
    }
  },
  methods: {
    ...  
```

用之前注册的账号登录，跳转到首页：

![12-9](https://doc.shiyanlou.com/courses/3472/1557563/516e8e54a22063fe4079571577c79856-0)

然后在登录状态下进入登录和注册页面，可以看到会自动跳转到首页：

![12-10](https://doc.shiyanlou.com/courses/3472/1557563/e6c411e873171ede253e69380304381d-0/wm)

如果在路由跳转中，控制台打印了错误提示，尝试在 `src/router/index.js` 中的文末添加以下代码：

```javascript
const originalPush = VueRouter.prototype.push;
VueRouter.prototype.push = function push(location) {
  return originalPush.call(this, location).catch(err => err)
};
```

### 退出登录状态

来完善下我们的用户登录、页面跳转到退出登录的流程：

1. 在已登录时，导航栏添加退出菜单，未登录时隐藏此菜单。
2. 在已登录时，隐藏登录和注册菜单，并显示用户名，未登录时显示这两个菜单，并隐藏用户名。
3. 登录状态和用户名均保存在 Vuex 中，可以通过 computed 获取。

在 `src/components/Header.vue` 中添加以下内容：

```
<template>
  <el-menu
    class="header-menu"
    :default-active="activeIndex"
    :router="true"
    mode="horizontal"
  >
    <el-menu-item index="Home" :route="{ name: 'Home' }">首页</el-menu-item>
    <el-menu-item
      class="login"
      index="Login"
      :route="{ name: 'Login' }"
      v-show="!isLogin"
      >登录</el-menu-item
    >
    <el-menu-item
      class="register"
      index="Register"
      :route="{ name: 'Register' }"
      v-show="!isLogin"
      >注册</el-menu-item
    >
    <!-- 为了和其他菜单样式保持一致，请一定要添加类名 el-menu-item -->
    <div class="el-menu-item exit" @click="exitButton()" v-show="isLogin">
      退出
    </div>
    <!-- 为了和其他菜单样式保持一致，请一定要添加类名 el-menu-item -->
    <div class="el-menu-item username" v-show="isLogin">
      <!-- 图标来自于Element UI官方图标库 -->
      <i class="el-icon-user-solid"></i>{{ username }}
    </div>
  </el-menu>
</template>

<script>
import Cookies from 'js-cookie'

export default {
  name: 'Header',
  data() {
    return {}
  },
  computed: {
    // 当前激活菜单的 index
    activeIndex() {
      return this.$route.name //  获取当前路由名称
    },
    // 登录状态
    isLogin() {
      return this.$store.getters.isLogin
    },
    // 用户名
    username() {
      return this.$store.getters.username
    }
  },
  methods: {
    // 退出登录
    exitButton() {
      Cookies.set('token', '')
      this.$router.push({ path: '/login' }) //  退出登录后跳转到登录页面
      this.$message.success('退出登录成功！')
    }
  }
}
</script>

<style lang="stylus" scoped>
.header-menu {
  padding: 0 24px;

  .login, .register, .username, .exit {
    float: right;
  }
}
</style>
```

来看下登录、跳转到首页、退出登录流程的效果：

![12-11](https://doc.shiyanlou.com/courses/3472/1557563/c5a344b3c32f52e285db61ce18bda0ec-0/wm)



下一步

# 视频流实时播放

![image-20211221095430164](E:\Document\Typora\img\image-20211221095430164.png)



## 不同码流的分析

[前端VUE播放RTSP、RTMP、HLS、FLV视频流的解决方案_清静为天下的博客-CSDN博客_vue播放rtsp](https://blog.csdn.net/weixin_45835850/article/details/116190008?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link)





## ffmpeg推流

[windows环境下python使用ffmpeg rtsp推流_嘿，不许笑的博客-CSDN博客_python 推rtsp流](https://blog.csdn.net/qq_43994782/article/details/118941373)

~~~
ffmpeg -re -stream_loop -1 -i （你的文件名） -c copy -f rtsp rtsp://127.0.0.1:8554/video
#简单对参数说明
-re  是以流的方式读取
-stream_loop -1   表示无限循环读取
-i  就是输入的文件
-f  格式化输出到哪里
~~~



ffmpeg运行命令

~~~
.\ffmpeg -re -stream_loop -1 -i .\1003to1002.mp4 -c copy -f rtsp rtsp://127.0.0.1:8554/video
~~~

`-stream_loop -1`是

`-c copy`是“-c”参数的一种很经常的用法，顾名思义，复制照抄输入文件原来的编解码器所做的事。

路径`C:\ffmpeg\bin`

rtsp路径 `rtsp://127.0.0.1:8554/video`

+ rtsp

rtsp服务器路径`E:\Download\Compressed\rtsp-simple-server_v0.17.11_windows_amd64`

+ nginx

路径`E:\Download\Compressed\nginx-1.7.11.3-Gryphon`

参考教程[Windows下实现ffmpeg+nginx+rtmp+hls实现直播推流拉流（低延时）_u011925282的专栏-CSDN博客_hls推流](https://blog.csdn.net/u011925282/article/details/102580420)

运行命令`./nginx.exe -c conf\nginx-win.conf`

[windows中nginx启动报bind() to 0.0.0.0:80 failed（An attempt was made to access a socket in a way forbid）_蓝色格子ren的博客-CSDN博客](https://blog.csdn.net/github_38924695/article/details/104155377)

实际上rtmp端口改为80就可以了。

检查命令` netstat -aon | findstr :80`

运行命令

~~~
ffmpeg -i rtsp://127.0.0.1:8554/video -fflags flush_packets -max_delay 1 -an -flags -global_header -hls_time 1 -hls_list_size 3 -hls_wrap 3 -vcodec copy -f flv -r 25 -an rtmp://localhost:1935/hls/cctv1
~~~

rtmp地址：`rtmp://localhost:1935/hls/cctv1`

+ nginx-http-flv

学习资料

文件路径`E:\Download\Compressed\nginx-http-flv`

http-fly运行命令`./nginx.exe -c conf\nginx.conf`

ffmpeg命令

~~~
ffmpeg  -i ./1003to1002.mp4 -g 25 -vcodec libx264  -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost:1935/live/streamid
~~~

报错

~~~
[flv @ 000002342e7eb080] Failed to update header with correct duration.1.2kbits/s speed=5.84x
[flv @ 000002342e7eb080] Failed to update header with correct filesize.
~~~

修改命令

~~~
ffmpeg  -i ./1003to1002.mp4 -g 25 -vcodec libx264  -preset:v ultrafast -tune:v zerolatency -f flv -c copy -flvflags no_duration_filesize rtmp://localhost:1935/live/streamid 
~~~

可以修改ip

~~~
ffmpeg -stream_loop -1 -i ./1003to1002.mp4 -g 25 -vcodec libx264  -preset:v ultrafast -tune:v zerolatency -f flv -c copy -flvflags no_duration_filesize rtmp://127.0.0.1:1935/live/streamid 
~~~

`-stream_loop -1 `为循环播放

~~~
ffmpeg -stream_loop -1 -i ./1003to1002.mp4 -f flv -flvflags no_duration_filesize rtmp://127.0.0.1:1935/myapp/123 
~~~



~~~
ffmpeg -stream_loop -1 -i ./1003to1002.mp4 -f flv -flvflags no_duration_filesize rtmp:/127.0.0.1:8080/myapp/123 
~~~

~~~
ffmpeg -stream_loop -1 -i ./1003to1002.mp4 -c copy -f flv -flvflags no_duration_filesize rtmp:/localhost:8080/myapp/123 
~~~



一定要有`-c copy`不然会降低分辨率，不过这个分辨率会卡顿





`8080`对应nginx配置中的http端口号，`myapp`匹配rtmp对应的application，123为流id。

所以对应的http路径为`http://localhost:8080/live?port=1935&app=myapp&stream=123`







### 端口问题处理

+ 查看80端口的占用情况

~~~
netstat -aon | findstr "80"
~~~

+ 查看nginx master进程号

~~~
ps aux | grep nginx
~~~

+ 根据pid查看使用的端口号

~~~
netstat -anp | grep ${pid}   # pid 为上面查询出来的nginx master进程号
~~~



## vue显示方案

IPC视频流怎么实时在WEB浏览器播放，视频流格式是RTSP。
 一、FFmpeg + nginx 将转 hls 通过 video.js 在支持h5浏览器播放
 不足：hls延迟较rtmp、http-flv大
 二、FFmpeg + nginx-rtmp-module + h5 video，rtsp转rtmp播放
 注：通过video.js播放rtmp流。需要将代码放到服务器，本地windows电脑无法播放
 不足：需要浏览器开启flash
 三、FFmpeg + nginx-http-flv-module + flv.js，rtsp转rtmp，直接播放flv格式
 基于nginx-rtmp-module，通过配置将rtmp转为flv，最后通过flv.js播放。
 这种方式是最理想的，我目前找到的方案。当然单指不想花钱买收费方案的。
 四、WebRTC
 五、streamedian
 六、h5stream
 七、liveqing

[海康摄像头开发SRS+ffmpeg+http-flv+flv.js(二) - 简书 (jianshu.com)](https://www.jianshu.com/p/cdc38940f245)



### vue-video-player

1. 安装插件

~~~
npm install vue-video-player --save
~~~

+ 全局引用

在main.js中全局配置插件

```bash
import VideoPlayer from 'vue-video-player'
require('video.js/dist/video-js.css')
require('vue-video-player/src/custom-theme.css')
Vue.use(VideoPlayer)
```

+ 部分引用



该方法不支持rtsp格式码流。

### h5stream

[如何在VUE中播放RTSP 实时视频，延迟要小于500ms_H5Stream/HTML5 Streaming -CSDN博客_vue播放rtsp视频流](https://blog.csdn.net/video_dc/article/details/85447278?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.fixedcolumn)

### RTSP

[vue+播放rtsp流视频监控_恶鬼wsd的博客-CSDN博客_vue播放rtsp视频流](https://blog.csdn.net/qq_45068078/article/details/115906108?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.fixedcolumn)

### flv

[nginx-http-flv-module/README.CN.md at master · winshining/nginx-http-flv-module (github.com)](https://github.com/winshining/nginx-http-flv-module/blob/master/README.CN.md)

[浏览器不支持flash插件之后，h5播放rtmp直播流的解决方案_浩星-CSDN博客_rtmp 浏览器支持](https://blog.csdn.net/qq_41619796/article/details/118991296)

[FLV方式实现网页FFmpeg推流无插件播放_igocsdn的博客-CSDN博客_ffmpeg推flv流](https://blog.csdn.net/igocsdn/article/details/118753920)

[ffmpeg 推流FLV文件，采用rtmp协议_无极生太极-CSDN博客_ffmpeg推流flv](https://blog.csdn.net/qianyuxingkong/article/details/110476394?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.highlightwordscore&spm=1001.2101.3001.4242.1)

[【入门】无插件web直播解决方案，ffmpeg+nginx-http-flv-module+flv.js_stringKai的博客-CSDN博客_ffmpeg flv.js](https://blog.csdn.net/string_kai/article/details/100598268)

+ 官方文档

[nginx-http-flv-module/README.CN.md at master · winshining/nginx-http-flv-module (github.com)](https://github.com/winshining/nginx-http-flv-module/blob/master/README.CN.md)

这个不需要rtsp转为rtmp流。

视频推流

~~~
ffmpeg  -i ./1003to1002.mp4 -g 25 -vcodec libx264  -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1:1935/myapp/mystream
~~~

摄像头推流

~~~
ffmpeg -f dshow -i "Integrated Webcam" -g 25 -vcodec libx264  -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1:1935/myapp/mystream
~~~

[利用ffmpeg实现rtmp推流 - 简书 (jianshu.com)](https://www.jianshu.com/p/c141fc7881e7)

报错`rtmp://127.0.0.1:1935/myapp/mystream: I/O error`

[直播协议 HTTP-FLV 详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/28722048)

FFmpeg + nginx-http-flv-module + flv.js，rtsp转rtmp，直接播放flv格式
 基于nginx-rtmp-module，通过配置将rtmp转为flv，最后通过flv.js播放。

#### 报错问题解决

~~~
rtmp://localhost:1935/myapp/mystream: I/O error
~~~

路径地址不对。





### RTMP

[使用FFmpeg将rtsp流摄像头视频转码为rtmp播放 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/62021755?from_voters_page=true)

[Windows下实现ffmpeg+nginx+rtmp+hls实现直播推流拉流（低延时）_u011925282的专栏-CSDN博客_hls推流](https://blog.csdn.net/u011925282/article/details/102580420)

安装vue-video

~~~
npm install vue-video-player --save 
npm install videojs-flash --save
~~~

### vlc

[vue播放rtsp视频_真真的博客-CSDN博客_vue播放rtsp视频流](https://blog.csdn.net/weixin_43292447/article/details/106644950?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5.highlightwordscore&spm=1001.2101.3001.4242.4)

### vue+播放rtsp流视频监控

[vue+播放rtsp流视频监控_恶鬼wsd的博客-CSDN博客_vue播放rtsp视频流](https://blog.csdn.net/qq_45068078/article/details/115906108?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.fixedcolumn)

### ckplayer

[vue-cli3.0实现播放rtmp直播流_浩星-CSDN博客_vue播放rtmp流](https://blog.csdn.net/qq_41619796/article/details/108535785)

这个好像也是基于flash的

### srs流服务器



搭建SRS实现WebRTC播放

[搭建SRS实现WebRTC播放_igocsdn的博客-CSDN博客_srs webrtc推流](https://blog.csdn.net/igocsdn/article/details/119539963)

[SRS 4.0配置支持WebRTC推拉流 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/371944795)

### webrtc

[后续---简单WebRTC快速推送RTSP流视频 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv14070290?spm_id_from=333.999.0.0)

[rtsp流+vue进行视频播放（海康威视、大华摄像头）_村头杂货铺的博客-CSDN博客_vue 海康威视](https://blog.csdn.net/qq_36524745/article/details/117839874?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.fixedcolumn)







### SRS+ffmpeg

 [海康摄像头开发SRS+ffmpeg+http-flv+flv.js(二) - 简书 (jianshu.com)](https://www.jianshu.com/p/cdc38940f245)



### vue+flvjs播放flv文件

+ OBS推流

![image-20211222164507870](E:\Document\Typora\img\image-20211222164507870.png)

[Vue+flvjs播放flv文件_CaseyWei-CSDN博客_vue 播放flv](https://blog.csdn.net/caseywei/article/details/109065752)

[HTTP-FLV直播初探 - 冒雨ing - 博客园 (cnblogs.com)](https://www.cnblogs.com/saysmy/p/7851911.html)



## 终于跑通了

+ nginx路径：`\Download\Compressed\nginx-http-flv`   运行命令` .\nginx.exe -c conf\nginx-win.conf`

+ ffmpeg运行命令`ffmpeg -stream_loop -1 -i ./1003to1002.mp4 -c copy -f flv -flvflags no_duration_filesize rtmp:/127.0.0.1/myapp/1233 `

+ 代码的url为`"http://127.0.0.1:8080/live?port=1935&app=myapp&stream=1233"`

vue2可以使用vue3用不了这个代码

~~~
<template>
  <div>
    <video
      id="videoElement"
      controls
      autoplay
      muted
      width="1080px"
      height="606px"
    />
    <p><button @click="play">播放</button></p>
  </div>
</template>

<script>
import flvjs from "flv.js";
export default {
  data() {
    return {
      flvPlayer: null,
    };
  },
  mounted() {
    if (flvjs.isSupported()) {
      var videoElement = document.getElementById("videoElement");
      this.flvPlayer = flvjs.createPlayer({
        type: "flv",
        isLive: true,
        hasAudio: false,
        url: "http://127.0.0.1:8080/live?port=1935&app=myapp&stream=1233",
      });
      this.flvPlayer.attachMediaElement(videoElement);
      this.flvPlayer.load();
      this.flvPlayer.play();
    }
  },
  methods: {
    play() {
      this.flvPlayer.play();
    },
  },
};
</script>
~~~

