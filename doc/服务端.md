# Go

+ 学习资料

[the-way-to-go_ZH_CN/directory.md at master · unknwon/the-way-to-go_ZH_CN (github.com)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md)

[Go 资料收集 · GoCN社区](https://gocn.vip/wiki/books)

[Go 语言官方文档](http://golang.org/doc/)

[Go 入门指南](https://github.com/Unknwon/the-way-to-go_ZH_CN)

[Go web 编程](https://github.com/astaxie/build-web-application-with-golang/blob/master/LICENSE.md)

[Go - 开发者手册 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/doc/1101)

[《跟煎鱼学 Go》 (eddycjy.com)](https://eddycjy.com/go-categories/)

+ 实验楼课程的代码

~~~
wget https://labfile.oss.aliyuncs.com/courses/11/Golang_Programming.zip
~~~



## import

[Go语言中import导入包时：点. 、下划线_ 、别名的用法_郝同学的博客-CSDN博客](https://blog.csdn.net/qq_42346574/article/details/112260070?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242.2)



1.问题前景：
在接触到Go的相关的项目的时候，突然发现有些文件中导入的包前边有一些看不懂的符号，如下：

~~~
import (
	v2 "github.com/YFJie96/wx-mall/controller/api/v2"
	_ "github.com/YFJie96/wx-mall/docs"
	. "fmt"
	"github.com/gin-gonic/gin"
	"github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"
)
上边的v2 和 _和 “fmt”前边的. 各自都代表什么意思？这就引发了思考。
~~~

2.相关方法解释：
经过查阅了相关资料：

(1) 别名v2:
此处的v2相当于是上述导入包的一个别名，我们可以直接使用 v2.WxLogin来调用包中的接口或方法。

(2) 下划线_:
此处的下划线在最初的时候，我也十分好奇究竟是什么作用，而且发现导入的包未被使用。
最终查阅得到：

~~~
在导入路径前加入下划线表示只执行该库的 init 函数而不对其它导出对象进行真正地导入。因为 Go 语言的数据库驱动都会在 init 函数中注册自己，所以我们只需要进行上述操作即可；否则的话，Go 语言的编译器会提示导入了包却没有使用的错误。
~~~

(3) 点.:
此处的.，含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”) 可以省略的写成Println(“hello world”)

## IDE和环境配置

### GOROOT 与 GOPATH

在介绍常用 IDE 之前，我们先来了解一下 Go 的环境变量配置，实际上在之前的课程中我们已经有所介绍了。

**GOROOT**

就是 go 的安装路径。在 `~/.bash_profile` 中添加下面语句：

```bash
GOROOT=/usr/local/go
export GOROOT
```

当然，要执行 go 命令和 go 工具，就要配置 go 的可执行文件的路径。 操作如下：

在 `~/.bash_profile` 中配置如下：

```bash
export $PATH:$GOROOT/bin
```

**GOPATH**

GOPATH 是作为编译后二进制的存放目的地和 import 包时的搜索路径 （其实也是你的工作目录，你可以在 src 下创建你自己的 go 源文件，然后开始工作）。

GOPATH 之下主要包含三个目录：

- `bin`：目录主要存放可执行文件；
- `pkg`：目录存放编译好的库文件；
- `src`：目录下主要存放 Go 的源文件。

不要把 GOPATH 设置成 Go 的安装路径，可以自己在用户目录下面创建一个目录，如 gopath。操作如下：

```bash
cd ~
mkdir gopath

# 在 ~/.bash_profile 中添加如下语句:
GOPATH=/Users/username/gopath
```

### IDE

Go 语言在刚推出时并没有专门针对 Go 语言开发的 IDE,不过还好 Go 提供的插件比较完善。开发者可以使用 IDEA、Eclipse 工具安装 Go 插件进行 Go 语言开发。直到 2017 年著名的捷克公司 JetBrains 才发布了第一款专门针对 Go 语言开发的 IDE：Goland。本节内容也着重为大家介绍 IDEA 与 Goland。这两款软件都来自 JetBrains 公司，大家可以在[官网](https://www.jetbrains.com/)下载。由于实验环境不支持安装这两款软件，大家可以自行在本地电脑进行安装。

**IDEA**：IntelliJ idea 是一款非常强大的 IDE，支持丰富的插件。安装配置都是非常简单的，主要需要安装插件 Go，也可以安装 Markdown 的插件，便于读写 Markdown 文件。

首先打开 IDEA，然后点击左上角”File->Settings->Plugins”；

![Plugins](https://doc.shiyanlou.com/document-uid949121labid10288timestamp1552542329146.png)

然后点击 "Browse repositories"；然后在搜索栏搜索插件 `GO`；选择名为 `GO` 的插件进行安装。

![install](https://doc.shiyanlou.com/document-uid949121labid10288timestamp1552542339121.png)

插件安装完成后重启 IDEA, 再打开 `setting`，添加 `go sdk`。再点击 `GO` 对 `SDK` 进行设置，首先添加 `GOROOT` 也就是 GO 的安装路径，再设置 `GOPATH`。![SDK](https://doc.shiyanlou.com/document-uid949121labid10288timestamp1552542346099.png) 然后就可以在 `GOPATH` 下的 `src` 目录下新建源文件了。

**Goland**: Goland 是专门针对 Go 开发的一款 IDE，功能强大且整合了 IntelliJ 平台的有关 go 语言的编码辅助功能和工具集成特点。但是比较遗憾的是它没有免费社区版，想要使用它必须要购买注册码。

和 IDEA 一样，使用同样的方法进行下载安装，没有注册码的同学可以选择 30 天免费试用，然后打开设置，无需下载 GO 插件，直接进行添加 `GOROOT` 和 `GOPATH` 就可以新建项目进行开发了。对安装和配置步骤存在疑问的同学，可以在评论区留言提问，也可以在网上自行查阅相关教程。







## 基础

- 用`go get`拉取新的依赖
  - 拉取最新的版本(优先择取 tag)：`go get golang.org/x/text@latest`
  - 拉取 `master` 分支的最新 commit：`go get golang.org/x/text@master`
  - 拉取 tag 为 v0.3.2 的 commit：`go get golang.org/x/text@v0.3.2`
  - 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：`go get golang.org/x/text@342b2e`
  - 用 `go get -u` 更新现有的依赖
  - 用 `go mod download` 下载 go.mod 文件中指明的所有依赖
  - 用 `go mod tidy` 整理现有的依赖
  - 用 `go mod graph` 查看现有的依赖结构
  - 用 `go mod init` 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)
- 用 `go mod edit` 编辑 go.mod 文件
- 用 `go mod vendor` 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)
- 用 `go mod verify` 校验一个模块是否被篡改过 +

+ go.sum

`go.sum` 文件详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。

+ go.mod

`go.mod` 文件是启用了 Go modules 的项目所必须的最重要的文件，因为它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头，目前有以下 5 个动词:

- module：用于定义当前项目的模块路径。
- go：用于设置预期的 Go 版本。
- require：用于设置一个特定的模块版本。
- exclude：用于从使用中排除一个特定的模块版本。
- replace：用于将一个模块版本替换为另外一个模块版本。

你可能还会疑惑 `indirect` 是什么东西，`indirect` 的意思是传递依赖，也就是非直接依赖。

## 基础语法

#### 并发编程

Go 语言引入了 `goroutine`，它是 Go 实现快速高效的并发编程的关键。通过调用 `go` 关键字，我们就可以让函数以 goroutine 的方式进行运行，也就是以协程为单位进行运行。协程比线程更加的轻量级，也更节省系统资源，这使得我们可以创建大量的 goroutine，从而进行轻松且高质量的并发编程。同时，goroutine 内部采用管道 `channel` 进行消息传递，从而实现共享内存。在第五章我们还将对 Go 并发编程进行详细的讲解。

#### 错误处理

Go 语言中的错误处理的哲学和 C 语言一样，函数通过返回错误类型 (`error`) 或者 `bool` 类型（不需要区分多种错误状态时）表明函数的执行结果，调用检查返回的错误类型值是否是 `nil` 来判断调用结果。并引入了 defer 关键字用于标准的错误处理流程，并提供了内置函数 `panic`、`recover` 完成异常的抛出与捕捉。

#### 垃圾回收

Go 语言自带垃圾自动回收的功能，让 Go 语言不需要 `delete` 关键字，也不需要 `free()` 来释放内存。因此开发者无需考虑何时需要释放之前分配的内存的问题，系统会自动帮我们判断，并在适当的时候进行垃圾处理。垃圾自动回收是 Go 语言的一个特点，也是一大亮点。

#### 多返回值

Go 语言和 Python 一样也支持函数的多返回值功能，这个特性让开发者可以从原来用各种比较别扭的方式返回多个值得痛苦中解脱出来，不需要为了一次返回多个值而专门定义一个结构体。并且每个返回值都有自己的名字，开发者还可以选择具体需要返回的值，只需要使用下划线作为占位符来丢掉不要的返回值即可。

#### 匿名函数

Go 语言支持常规的匿名函数和闭包，开发者可以随意对匿名函数变量进行传递和调用，下面就是一个匿名函数样例：

```go
f := func(x,y int) int {
    return x+y
}
```



### 常量

常量使用关键字 `const` 声明，下面有几个例子：

```go
const limit = 512
const top uint16 = 1421
const Pi float64 = 3.1415926
const x,y int = 1,3 //多重赋值
```

Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么该常量就是无类型常量，也叫字面常量。

当需要设置多个常量的时候，不必重复使用 `const` 关键字，可以使用以下语法：

```go
const (
    Cyan = 0
    Black = 1
    White = 2
)
```

Go 语言还预定义了这些常量：`true`、`false`、`iota`。

`iota` 是一个可以被编译器修改的常量，在 `const` 关键字出现时被重置为 0，在下一个 `const` 出现之前，每出现一次 `iota`，其所代表的数字自动加 1。下面通过一个例子讲解 `iota` 的用法：

```go
const (
    a = iota  //a == 0
    b = iota  //b ==1
    c = iota  //c == 2
)

const d = iota //d==0,因为const的出现，iota被重置为0
```

### 变量

变量是所有语言最基本和最重要的组成部分。Go 语言引入了关键字 `var` 对变量进行声明，也可以使用 `:=` 来对变量直接进行初始化，Go 编译器会自动推导出该变量的类型，这大大的方便了开发者的工作。但是需要注意的是 `:=` 左侧的变量不能是已经被声明过的，否则会导致编译器错误。

以下是 Go 声明和初始化变量的各种方法：

~~~
var a int
var b string
var c float64
var d [5] int  //数组
var e [] int   //数组切片
var f * int    //正确
var v1 int = 5 //正确
var v2 = 5     //正确，编译器自动推导出V2类型
v3 := 5        //正确，编译器自动推导出V3的类型
~~~

#### 多重赋值

Go 语言提供了大多数语言不支持的多重赋值，这使得变量的交换变得十分简单。下面通过一个例子来了解 Go 语言的多重赋值：

```go
i := 2
j := 3
i, j = j, i  //交换i和j的值，此时i == 3，j == 2
```

这样的方式可以一行代码实现变量的交换，明显的减少代码的行数，而不需要像 C/C++ 那样引入一个中间变量。

#### 整型

Go 语言提供了 11 种整型，如下列表所示。

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| `byte`    | 等同于 uint8                                                 |
| `int`     | 依赖于不同平台下的实现，可以是 int32 或者 int64              |
| `int8`    | [-128, 127]                                                  |
| `int16`   | [-32768, 32767]                                              |
| `int32`   | [-2147483648, 2147483647]                                    |
| `int64`   | [-9223372036854775808, 9223372036854775807]                  |
| `rune`    | 等同于 int32                                                 |
| `uint`    | 依赖于不同平台下的实现，可以是 uint32 或者 uint64            |
| `uint8`   | [0, 255]                                                     |
| `uint16`  | [0, 65535]                                                   |
| `uint32`  | [0, 4294967295]                                              |
| `uint64`  | [0, 18446744073709551615]                                    |
| `uintptr` | 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） |

### 浮点型

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| float32   | ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 |
| float64   | ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 |
| complex32 | 复数，实部和虚部都是 float32                                 |
| complex64 | 复数，实部和虚部都是 float64                                 |

### 布尔类型

Go 语言提供了内置的布尔值 `true` 和`false`。Go 语言支持标准的逻辑和比较操作，这些操作的结果都是布尔值。值得注意的地方是可以通过 `!b` 的方式反转变量 `b` 的真假。需要注意的是布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。实例代码如下：

```go
var a bool
a = true
b := (2 == 3) //b也会被推导为bool类型

//错误示范
var b bool
b = 1 //编译错误
b = bool(1) //编译错误
```



### 字符串

Go 语言中的字符串是 [UTF-8](http://zh.wikipedia.org/wiki/UTF-8) 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

Go 语言中字符串的可以使用双引号 (`"`) 或者反引号 (```) 来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 `\n` 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子：

```go
t1 := "\"hello\""             //内容： "hello"
t2 := `"hello"`               //内容：和t1一致
t3 := "\u6B22\u8FCE"          //内容：欢迎
```

Go 语言中的部分转义字符如下表所示：

| 转义字符 | 含义                                |
| -------- | ----------------------------------- |
| `\\`     | 表示反斜线                          |
| `\'`     | 单引号                              |
| `\"`     | 双引号                              |
| `\n`     | 换行符                              |
| `\uhhhh` | 4 个 16 进制数字给定的 Unicode 字符 |

在 Go 语言中单个字符可以使用单引号 (`'`) 来创建。之前的课程中，我们有学习过 `rune` 类型，它等同于 `int32`，在 Go 语言中，一个单一的字符可以用一个单一的 `rune` 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。

在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 `range` 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作：

| 语法             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| `s += t`         | 将字符串 t 追加到 s 末尾                                     |
| `s + t`          | 将字符串 s 和 t 级联                                         |
| `s[n]`           | 从字符串 s 中索引位置为 n 处的原始字节                       |
| `s[n:m]`         | 从位置 n 到位置 `m-1` 处取得的字符（字节）串                 |
| `s[n:]`          | 从位置 n 到位置 `len(s)-1` 处取得的字符（字节）串            |
| `s[:m]`          | 从位置 0 到位置 `m-1` 处取得的字符（字节）串                 |
| `len(s)`         | 字符串 s 中的字节数                                          |
| `len([]rune(s))` | 字符串 s 中字符的个数，可以使用更快的方法 `utf8.RuneCountInString()` |
| `[]rune(s)`      | 将字符串 s 转换为一个 unicode 值组成的串                     |
| `string(chars)`  | chars 类型是 `[]rune` 或者 `[]int32`, 将之转换为字符串       |
| `[]byte(s)`      | 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 |

让我们尝试一个例子，创建源文件 `string_t.go`，然后输入以下源代码：



### 函数

在 Go 语言中可以通过 `unsafe.Sizeof` 函数进行，创建源文件 `type_length.go`，输入以下代码：

~~~
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    a := 12
    fmt.Println("length of a: ", unsafe.Sizeof(a))
    var b int = 12
    fmt.Println("length of b(int): ", unsafe.Sizeof(b))
    var c int8 = 12
    fmt.Println("length of c(int8): ", unsafe.Sizeof(c))
    var d int16 = 12
    fmt.Println("length of d(int16): ", unsafe.Sizeof(d))
    var e int32 = 12
    fmt.Println("length of e(int32): ", unsafe.Sizeof(e))
    var f int64 = 12
    fmt.Println("length of f(int64): ", unsafe.Sizeof(f))
}
~~~

首先声明了目前的源文件属于 `main` 包，然后导入了 `fmt` 和 `unsafe` 包，`fmt` 包用于格式化字符串，`unsafe` 包含了用于获取 Go 语言类型信息的方法。然后在 `main()` 函数中，我们分别声明了几种类型的整型变量，并通过 `unsafe.Sizeof` 方法获取该类型的字节长度。

+ 函数的定义

在 Go 语言中，函数的基本组成包括：关键字 `func`、函数名、参数列表、返回值、函数体和返回语句，这里我们用一个简单的加法函数来对函数的定义进行说明。

```go
package add

func Add(a int, b int) (num int){
    return a + b
}
```

+ 函数的调用

函数调用非常简单，先将被调用函数所在的包导入，就可以直接使用该函数了。注意需要把包文件夹放到 `$GOPATH` 目录中，实例如下：

```go
package main

import (
    "add" //导入 add 包
    "fmt"
)

func main(){
    c := add.Add(1, 2) //调用 add 包中的 add 函数
    fmt.Println(c)
}
```

+ 函数的多个返回值

~~~
package Divide
import "errors"

func divide (a int, b int) (num int, err error){ //定义两个返回值
    if b == 0 {
        err = errors.New("被除数不能为零！")
        return
    }
    return a / b, nil   //支持多个返回值
}
~~~

+ 匿名函数

在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下：

```go
func (a, b, c int) bool {
    return a * b < c
}
```

你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下：

```go
x := func (a, b, c int) bool {
    return a * b < c
}

func (a, b, c int) bool {
    return a * b < c
} (1, 2, 3) //小括号内直接给参数列表表示函数调用
```



### 类型转换

在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下：

```go
func (a, b, c int) bool {
    return a * b < c
}
```

你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下：

```go
x := func (a, b, c int) bool {
    return a * b < c
}

func (a, b, c int) bool {
    return a * b < c
} (1, 2, 3) //小括号内直接给参数列表表示函数调用
```



### 格式化字符串

Go 语言标准库中的 `fmt` 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 `io.Writer` 接口的值以及其他字符串。目前为止我们使用了 `fmt.Printf` 和 `fmt.Println`，对于前者的使用，就像 C 语言中的 `printf` 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下：

| 格式化指令 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| `%%`       | % 字面量                                                     |
| `%b`       | 一个二进制整数，将一个整数格式化为二进制的表达方式           |
| `%c`       | 一个 Unicode 的字符                                          |
| `%d`       | 十进制数值                                                   |
| `%o`       | 八进制数值                                                   |
| `%x`       | 小写的十六进制数值                                           |
| `%X`       | 大写的十六进制数值                                           |
| `%U`       | 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符       |
| `%s`       | 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 |
| `%t`       | 以 true 或者 false 的方式输出布尔值                          |
| `%v`       | 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 |
| %T         | 输出值的类型                                                 |

常用的格式化指令修饰符如下：

- `空白` 如果输出的数字为负，则在其前面加上一个减号 `-`。如果输出的是整数，则在前面加一个空格。使用 `%x` 或者 `%X` 格式化指令输出时，会在结果之间添加一个空格。例如 `fmt.Printf("% X", "实")` 输出 E5 AE 9E。

- ```
  #
  ```

  - `%#o` 输出以 `0` 开始的八进制数据。
  - `%#x` 输出以 `0x` 开始的十六进制数据。

- `+` 让格式化指令在数值前面输出 `+` 号或者 `-` 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。

- `-` 让格式化指令将值向左对齐（默认值为像右对齐）。

- `0` 让格式指令以数字 0 而非空白进行填充。

### 数组

Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 `[ ]` 来索引，索引从 `0` 开始，到 `len(array)-1` 结束。数组使用以下语法创建：

- `[length]Type`
- `[N]Type{value1, value2, ..., valueN}`
- `[...]Type{value1, value2, ..., valueN}`

如果使用了 `...`（省略符）操作符，Go 语言会为我们自动计算数组的长度。在任何情况下，一个数组的长度都是固定的并且不可修改。数组的长度可以使用 `len()` 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 `cap()` 和 `len()` 函数返回值都是一样的。数组也可以使用和切片一样的语法进行切片，只是其结果为一个切片，而非数组。同样的，数组也可以使用 `range` 进行索引访问。

#### 切片

一般而言，Go 语言的切片比数组更加灵活，强大而且方便。数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。创建切片的语法如下：

- `make([ ]Type, length, capacity)`
- `make([ ]Type, length)`
- `[ ]Type{}`
- `[ ]Type{value1, value2, ..., valueN}`

内置函数 `make()` 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度，如果使用第一种语法创建，那么其长度为切片的容量 `capacity`；如果是第二种语法，那么其长度记为切片的长度 `length`。一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。另外可以通过内置的函数 `append()` 来增加切片的容量。



### switch语句

Go 语言中 `switch` 分支既可用于常用的分支就像 C 语言中的 `switch` 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 `switch` 语句不会自动贯穿，相反，如果想要贯穿需要添加 `fallthrough` 语句。表达式开关 `switch` 的语法如下：

```go
switch optionalStatement; optionalExpression {
    case expression1: block1
    ...
    case expressionN: blockN
    default: blockD
}
```

下面是个例子：

```go
switch {        // 没有表达式，默认为True值，匹配分支中值为True的分支
    case value < minimum:
        return minimum
    case value > maximum:
        return maximum
    default:
        return value
}
```

在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 `True`。

在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下：

```go
switch optionalStatement; typeSwitchGuard {
    case type1: block1
    ...
    case typeN: blockN
    default: blockD
}
```

说了这么多，让我们进行下练习，创建源文件 `switch_t.go`，输入以下代码：

```go
package main

import (
    "fmt"
)

func classchecker(items ...interface{}) { // 创建一个函数，该函数可以接受任意多的任意类型的参数
    for i, x := range items {
        switch x := x.(type) { // 创建了影子变量
        case bool:
            fmt.Printf("param #%d is a bool, value: %t\n", i, x)
        case float64:
            fmt.Printf("param #%d is a float64, value: %f\n", i, x)
        case int, int8, int16, int32, int64:
            fmt.Printf("param #%d is a int, value: %d\n", i, x)
        case uint, uint8, uint16, uint32, uint64:
            fmt.Printf("param #%d is a uint, value: %d\n", i, x)
        case nil:
            fmt.Printf("param #%d is a nil\n", i)
        case string:
            fmt.Printf("param #%d is a string, value: %s\n", i, x)
        default:
            fmt.Printf("param #%d's type is unknow\n", i)
        }
    }
}

func main() {
    classchecker(5, -17.98, "AIDEN", nil, true, complex(1, 1))

}
```

### 类型断言

说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。

接口是完全抽象的，不能实例化。`interface{}` 类型表示一个空接口，任何类型都满足空接口。也就是说 `interface{}` 类型的值可以用于表示任意 Go 语言类型的值。

这里的空接口有点类似于 Python 语言中的 object 实例。既然 `interface{}` 可以用于表示任意类型，那有的时候我们需要将 `interface{}` 类型转换为我们需要的类型，这个操作称为类型断言。

**一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言**。Go 语言中可以使用以下语法：

- `resultOfType, boolean := expression.(Type)`：安全的类型断言。
- `resultOfType := expression.(Type)`：非安全的类型断言，失败时程序会产生异常。

创建源文件 `type_t.go`，输入以下源文件：

```go
package main

import (
    "fmt"
)

func main() {
    x := uint16(65000)
    y := int16(x) // 将 x转换为int16类型
    fmt.Printf("type and value of x is: %T and %d\n", x, x) // %T 格式化指令的作用是输出变量的类型
    fmt.Printf("type and value of y is: %T and %d\n", y, y)

    var i interface{} = 99 // 创建一个interface{}类型，其值为99
    var s interface{} = []string{"left", "right"}
    j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型
    fmt.Printf("type and value of j is: %T and %d\n", j, j)

    if s, ok := s.([]string); ok { // 创建了影子变量，if的作用域中覆盖了外部的变量s
        fmt.Printf("%T -> %q\n", s, s)
    }
}
```

### error

Go 语言引入了一个错误处理的标准模式，即 `error` 接口，该接口定义如下：

```go
type error interface {
    Error() string
}
```

对于大多数函数，如果要返回错误，可以将 `error` 作为多返回值的最后一个：

```go
func foo(param int)(ret int, err error)
{
  ...
}
```

调用时的代码：

```go
n, err := foo(0)
if err != nil {
    //  错误处理
} else {
    // 使用返回值n
}
```

我们还可以自定义错误类型，创建源文件 `error.go`，输入以下代码：

```go
package main

import "fmt"
import "errors"

//自定义的出错结构
type myError struct {
    arg  int
    errMsg string
}
//实现Error接口
func (e *myError) Error() string {
    return fmt.Sprintf("%d - %s", e.arg, e.errMsg)
}

//两种出错
func error_test(arg int) (int, error) {
    if arg < 0  {
         return -1, errors.New("Bad Arguments - negtive!")
     }else if arg >256 {
        return -1, &myError{arg, "Bad Arguments - too large!"}
    }
    return arg*arg, nil
}

//相关的测试
func main() {
    for _, i := range []int{-1, 4, 1000} {
        if r, e := error_test(i); e != nil {
            fmt.Println("failed:", e)
        } else {
            fmt.Println("success:", r)
        }
    }
}
```

### defer

你可以在 Go 函数中添加多个 `defer` 语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个 `defer` 语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：

```go
func CopyFile(dst, src string) (w int64, err error) {
    srcFile, err := os.Open(src)
    if err != nil {
        return
    }

    defer srcFile.Close()

    dstFile, err := os.Create(dst)
    if err != nil {
        return
    }

    defer dstFile.Close()

    return io.Copy(dstFile, srcFile)
}
```

如果 `defer` 后面一条语句干不完清理工作，也可以使用一个匿名函数：

```go
defer func(){
    ...
}()
```

注意，`defer` 语句是在 `return` 之后执行的，新建源文件 `defer.go` 输入以下代码：

```go
func test() (result int) {
    defer func() {
        result = 12
    }()
    return 10
}

func main() {
    fmt.Println(test())     // 12
}
```



### panic 和 recover

`panic()` 函数用于抛出异常，`recover()` 函数用于捕获异常，这两个函数的原型如下：

```go
func panic(interface{})
func recover() interface{}
```

当在一个函数中调用 `panic()` 时，正常的函数执行流程将立即终止，但函数中之前使用 `defer` 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 `panic()` 流程，直至所属的 `goroutine` 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 `panic()` 函数时传入的参数，这个过程称为错误流程处理。

`panic()` 接受一个 `interface{}` 参数，可支持任意类型，例如：

```go
panic(404)
panic("network broken")
panic(Error("file not exists"))
```

在 `defer` 语句中，可以使用 `recover()` 终止错误处理流程，这样可以避免异常向上传递，但要注意 `recover()` 之后，程序不会再回到 `panic()` 那里，函数仍在 `defer` 之后返回。新建一个源文件 `error1.go`，输入以下代码：

```go
func foo() {
    panic(errors.New("i'm a bug"))
    return
}

func test() (result int) {
    defer func() {
        if r := recover(); r != nil {
            err := r.(error)
            fmt.Println("Cache Exception:", err)
        }
    }()
    foo()
    return 10
}

func main() {
    fmt.Println(test())     // 0
}
```



### 结构体

Go 语言的中结构体 `struct` 与 C++、JAVA 中的类 `class` 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。

- **type** typeName typeSpecification

其中，`typeName` 可以是一个包或者函数内唯一合法的 Go 标示符。`typeSpecification` 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型：

```go
type ColorPoint struct {
    color.Color     // 匿名字段(嵌入)
    x, y int        // 具名字段(聚合)
}
```

以上代码我们通过结构体自定义了类型 `ColorPoint`，结构体中 `color.Color` 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 `x` 和 `y` 是有变量名的，所以被称为具名字段。假如我们创建了类型 `ColorPoint` 的一个值 `point`（通过语法：`point := ColorPoint{}` 创建），那么这些字段可以通过 `point.Color`、`point.x`、`point.y` 访问。其他面向对象语言中的"类 (`class`)"、"对象 (`object`)"、"实例 (`instance`)"在 Go 语言中我们完全避开使用。相反的我们使用"类型 (`type`)"和其对应的"值"，其中自定义类型的值可以包含方法。

定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现：

```go
//先定义一个结构体Man
type Man struct{
    name string
    age int
}
//对象创建与初始化
man := new(Man)
man := &Man{}
man := &Man{"Tom", 18}
man := &Man{name: "Tom", age: 18}
```

为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。

```go
func NewMan(name string, age int) *Man {
    return &Man{name, age}
}
```



### 方法

方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 `func` 关键字和方法名之间必须写上接接受者。例如我们给类型 `Count` 定义了以下方法：

```go
type Count int

func (count *Count) Increment() { *count++ }  // 接受者是一个 `Count` 类型的指针
func (count *Count) Decrement() { *count-- }
func (count Count) IsZero() bool { return count == 0 }
```

以上代码中，我们在内置类型 `int` 的基础上定义了自定义类型 `Count`，然后给该类型添加了 `Increment()`、`Decrement()` 和 `IsZero()` 方法，其中前两者的接受者为 `Count` 类型的指针，后一个方法接收 `Count` 类型的值。

类型的方法集是指可以被该类型的值调用的所有方法的集合。

一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。

一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。

其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。

在以上定义的类型 `Count` 中，`*Count` 方法集是 `Increment()`, `Decrement()` 和 `IsZero()`，`Count` 的值的方法集是 `IsZero()`。但是因为 `Count` 类型的是可寻址的，所以我们可以使用 `Count` 的值调用全部的方法。

另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 `struct_t.go`，输入以下代码：

```go
package main

import "fmt"

type Count int // 创建自定义类型 Count

func (count *Count) Increment()  { *count++ } // Count类型的方法
func (count *Count) Decrement()  { *count-- }
func (count Count) IsZero() bool { return count == 0 }

type Part struct { // 基于结构体创建自定义类型 Part
    stat  string
    Count // 匿名字段
}

func (part Part) IsZero() bool { // 覆盖了匿名字段Count的IsZero()方法
    return part.Count.IsZero() && part.stat == "" // 调用了匿名字段的方法
}

func (part Part) String() string { // 定义String()方法，自定义了格式化指令%v的输出
    return fmt.Sprintf("<<%s, %d>>", part.stat, part.Count)
}

func main() {
    var i Count = -1
    fmt.Printf("Start \"Count\" test:\nOrigin value of count: %d\n", i)
    i.Increment()
    fmt.Printf("Value of count after increment: %d\n", i)
    fmt.Printf("Count is zero t/f? : %t\n\n", i.IsZero())
    fmt.Println("Start: \"Part\" test:")
    part := Part{"232", 0}
    fmt.Printf("Part: %v\n", part)
    fmt.Printf("Part is zero t/f? : %t\n", part.IsZero())
    fmt.Printf("Count in Part is zero t/f?: %t\n", part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，单还是可以访问

}
```

以上代码中，我们创建了 `Count` 类型，然后在其基础上又创建了结构体类型 `Part`。我们为 `Count` 类型定义了 3 个方法，并在 `Part` 类型中创建了方法 `IsZero()` 覆盖了其匿名字段 `Count` 中 `IsZero()` 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下：

```bash
$ go run struct_t.go
Start "Count" test:


Origin value of count: -1
Value of count after increment: 0
Count is zero t/f? : true

Start: "Part" test:
Part: <<232, 0>>
Part is zero t/f? : false
Count in Part is zero t/f?: true
```

### 组合

Go 语言虽然抛弃了继承，但是却提供了一个更加方便的组合特性。相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活。下面通过一段代码来了解组合的基本属性以及它与继承的不同之处。

先定义一个结构体 Base, 并为它添加两个方法 `Foo()` 和 `Bar()`：

```go
type Base struct{
    Name string
}

func (b *Base) Foo() {...}
func (b *Base) Bar() {...}

type Seed struct {
    Base
    ...
}

func (s *Seed) Foo() {
    s.Base.Foo()
    s.Bar()
    ...
}
```

上面代码先定义了一个 Base 类，然后定义了一个 Seed 类。Seed 类“继承”了 Base 类的所有成员属性和方法并重写了 `Foo()` 方法。同时在重写 `Foo()` 方法时调用了 Base 类的 `Foo()` 方法和 `Bar()` 方法。需要注意的是，若此时 Seed 的对象通过 `s.Foo()` 调用 `Foo()` 方法时，实际调用的是 Seed 重写过后的 `Foo()` 方法，而不是基类 Base 的 `Foo()` 方法，若想调用 Base 类的 `Foo()` 方法则要使用 `s.Base.Foo`，而调用没有重写的 `Bar()` 方法时，使用 `s.Bar()` 和`s.Base.Bar()` 效果是一样的。

### 接口

在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。

之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。`infterface{}` 类型是声明了空方法集的接口类型。任何一个值都满足 `interface{}` 类型，也就是说如果一个函数或者方法接收 `interface{}` 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 `interface_t.go`，输入以下代码：

```go
package main

import "fmt"

type Human struct { // 结构体
    name  string
    age   int
    phone string
}

//Human实现SayHi方法
func (h Human) SayHi() {
    fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

//Human实现Sing方法
func (h Human) Sing(lyrics string) {
    fmt.Println("La la la la...", lyrics)
}

type Student struct {
    Human  //匿名字段
    school string
    loan   float32
}

type Employee struct {
    Human   //匿名字段
    company string
    money   float32
}

// Employee重载Human的SayHi方法
func (e Employee) SayHi() {
    fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
        e.company, e.phone)
}

// Interface Men被Human,Student和Employee实现
// 因为这三个类型都实现了这两个方法
type Men interface {
    SayHi()
    Sing(lyrics string)
}

func main() {
    mike := Student{Human{"Mike", 25, "222-222-XXX"}, "MIT", 0.00}
    paul := Student{Human{"Paul", 26, "111-222-XXX"}, "Harvard", 100}
    sam := Employee{Human{"Sam", 36, "444-222-XXX"}, "Golang Inc.", 1000}
    Tom := Employee{Human{"Tom", 37, "222-444-XXX"}, "Things Ltd.", 5000}

    //定义Men类型的变量i
    var i Men

    //i能存储Student
    i = mike
    fmt.Println("This is Mike, a Student:")
    i.SayHi()
    i.Sing("November rain")

    //i也能存储Employee
    i = Tom
    fmt.Println("This is Tom, an Employee:")
    i.SayHi()
    i.Sing("Born to be wild")

    //定义了slice Men
    fmt.Println("Let's use a slice of Men and see what happens")
    x := make([]Men, 3)
    //这三个都是不同类型的元素，但是他们实现了interface同一个接口
    x[0], x[1], x[2] = paul, sam, mike

    for _, value := range x {
        value.SayHi()
    }
}
```

以上代码中，接口类型声明的变量能存储任何实现了该接口的类型的值。运行代码，输出如下：

```bash
go run interface_t.go
This is Mike, a Student:
Hi, I am Mike you can call me on 222-222-XXX
La la la la... November rain
This is Tom, an Employee:
Hi, I am Tom, I work at Things Ltd.. Call me on 222-444-XXX
La la la la... Born to be wild
Let's use a slice of Men and see what happens
Hi, I am Paul you can call me on 111-222-XXX
Hi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXX
Hi, I am Mike you can call me on 222-222-XXX
```

### 接口变量值的类型

我们知道接口类型声明的变量里能存储任何实现了该接口的类型的值。有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 `switch` 类型判断分支。以下的例子 `interface_t1.go` 我们使用了 `switch` 类型判断分支。

```go
package main

import (
    "fmt"
    "strconv"
)

type Element interface{}
type List []Element

type Person struct {
    name string
    age  int
}

// 实现了fmt.Stringer接口
func (p Person) String() string {
    return "(name: " + p.name + " - age: " + strconv.Itoa(p.age) + " years)"
}

func main() {
    list := make(List, 3)
    list[0] = 1       //an int
    list[1] = "Hello" //a string
    list[2] = Person{"Dennis", 70}

    for index, element := range list {
        switch value := element.(type) { // switch类型判断开关
        case int:
            fmt.Printf("list[%d] is an int and its value is %d\n", index, value)
        case string:
            fmt.Printf("list[%d] is a string and its value is %s\n", index, value)
        case Person:
            fmt.Printf("list[%d] is a Person and its value is %s\n", index, value)
        default:
            fmt.Println("list[%d] is of a different type", index)
        }
    }
}
```

运行结果：

```bash
$ go run interface_t1.go
list[0] is an int and its value is 1
list[1] is a string and its value is Hello
list[2] is a Person and its value is (name: Dennis - age: 70 years)
```

### 嵌入interface

在前面的课程中我们已经知道在结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 `interface1` 作为 `interface2` 的一个嵌入字段，那么 `interface2` 隐式的包含了 `interface1` 里的方法。如下例子中，`Interface2` 包含了 `Interface1` 的所有方法。

```go
type Interface1 interface {
    Send()
    Receive()
}

type Interface2 interface {
    Interface1
    Close()
}
```



## 并发编程

#### 并发与并行

并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过 CPU 时间片轮转使多个进程快速交替的执行。而并行的关键是你有同时处理多个任务的能力。并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）CPU 执行，如果可以就说明是并行，而并发是多个线程被（一个）CPU 轮流切换着执行。一个经典且通俗易懂的例子这样解释并发与并行的区别：并发是两个队列，使用一台咖啡机；并行是两个队列，使用两台咖啡机。如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人有事出去了半天，后面的人也只能等着他回来才能去接咖啡，这效率无疑是最低的。图解：

![并发与并行](https://doc.shiyanlou.com/document-uid949121labid10288timestamp1552542750355.png)

#### 协程

协程也叫轻量级线程。与传统的进程和线程相比，协程最大的优点就在于其足够“轻”，操作系统可以轻松创建上百万个协程而不会导致系统资源枯竭，而线程和进程通常最多不过近万个。而多数语言在语法层面上是不支持协程的，一般都是通过库的方式进行支持，但库的支持方式和功能不够完善，经常会引发阻塞等一系列问题，而 Go 语言在语法层面上支持协程，也叫 `goroutine`。这让协程变得非常简单，让轻量级线程的切换管理不再依赖于系统的进程和线程，也不依赖 CPU 的数量。

`goroutine` 是 Go 语言并行设计的核心。`goroutine` 是一种比线程更轻量的实现，十几个 `goroutine` 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 `goroutine` 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 `goroutine` 的 CPU (P) 转让出去，让其他 `goroutine` 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 `goroutine` 只需要简单的在需要执行的函数前添加 `go` 关键字即可。当执行 `goroutine` 时候，Go 语言立即返回，接着执行剩余的代码，`goroutine` 不阻塞主线程。下面我们通过一小段代码来讲解 `go` 的使用：

```go
//首先我们先实现一个 Add()函数
func Add(a, b int) {
    c := a + b
    fmt.Println(c)
}

go Add(1, 2) //使用go关键字让函数并发执行
```

Go 的并发执行就是这么简单，当在一个函数前加上 `go` 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 `go` 还需要酌情考虑。

接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 `goroutine.go`，输入以下代码：

```go
package main

import "fmt"

func Add(a, b int) {
    c := a + b
    fmt.Println(c)
}

func main() {
    for i := 0; i < 10; i++ {
        go Add(i, i)
    }
}
```

执行 `goroutine.go` 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 `goroutine`，然后主程序就退出了，而启动的 10 个 `goroutine` 还没来得及执行 `Add()` 函数，所以程序不会有任何输出。也就是说主 `goroutine` 并不会等待其他 `goroutine` 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（`channel`）就是专门解决并发通信问题的，下一节我们将详细介绍。

#### channel

`channel` 是`goroutine` 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 `goroutine` 之间发消息和接收消息。其实，就是在做 `goroutine` 之间的内存共享。`channel` 是类型相关的，也就是说一个 `channel` 只能传递一种类型的值，这个类型需要在 `channel` 声明时指定。

#### 声明与初始化

`channel` 的一般声明形式：**var** chanName **chan** ElementType。

与普通变量的声明不同的是在类型前面加了 `channel` 关键字，`ElementType` 则指定了这个 `channel` 所能传递的元素类型。示例：

```go
var a chan int //声明一个传递元素类型为int的channel
var b chan float64
var c chan string
```

初始化一个 `channel` 也非常简单，直接使用 Go 语言内置的 `make()` 函数，示例：

```go
a := make(chan int) //初始化一个int型的名为a的channel
b := make(chan float64)
c := make(chan string)
```

`channel` 最频繁的操作就是写入和读取，这两个操作也非常简单，示例：

```go
a := make(chan int)
a <- 1  //将数据写入channel
z := <-a  //从channel中读取数据
```



#### select

`select` 用于处理异步 IO 问题，它的语法与 `switch` 非常类似。由 `select` 开始一个新的选择块，每个选择条件由 `case` 语句来描述，并且每个 `case` 语句里必须是一个 `channel` 操作。它既可以用于 `channel` 的数据接收，也可以用于 `channel` 的数据发送。如果 `select` 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。

新建源文件 `channel.go`，输入以下代码：

```go
package main
import "time"
import "fmt"
func main() {
    c1 := make(chan string)
    c2 := make(chan string)
    go func() {
        time.Sleep(time.Second * 1)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(time.Second * 2)
        c2 <- "two"
    }()
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
```

以上代码先初始化两个 `channel` c1 和 c2，然后开启两个 `goroutine` 分别往 c1 和 c2 写入数据，再通过 `select` 监听两个 `channel`，从中读取数据并输出。

运行结果如下：

```bash
$ go run channel.go
received one
received two
```



#### 超时机制

通过前面的内容我们了解到，`channel` 的读写操作非常简单，只需要通过 `<-` 操作符即可实现，但是 `channel` 的使用不当却会带来大麻烦。我们先来看之前的一段代码：

```go
a := make(chan int)
a <- 1
z := <-a
```

观察上面三行代码，第 2 行往 `channel` 内写入了数据，第 3 行从 `channel` 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 `channel` 中没有数据，那么第 3 行代码会因为永远无法从 `a` 中读取到数据而一直处于阻塞状态。相反的，如果 `channel` 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 `goroutine` 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 `select` 来巧妙地实现超时处理机制，下面看一个示例：

```go
t := make(chan bool)
go func {
    time.Sleep(1e9) //等待1秒
    t <- true
}

select {
    case <-ch:  //从ch中读取数据

    case <-t:  //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作
}
```

这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。

#### channel 的关闭

`channel` 的关闭非常简单，使用 Go 语言内置的 `close()` 函数即可关闭 `channel`，示例：

```go
ch := make(chan int)
close(ch)
```

关闭了 `channel` 后如何查看 `channel` 是否关闭成功了呢？很简单，我们可以在读取 `channel` 时采用多重返回值的方式，示例：

```go
x, ok := <-ch
```

通过查看第二个返回值的 `bool` 值即可判断 `channel` 是否关闭，若为 `false` 则表示 `channel` 被关闭，反之则没有关闭。

## swagger生成文档

[使用go-swagger为golang API自动生成swagger文档 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1165462)

+ 查看swagger.json

  

## webSocket协议实现

WebSocket 协议解决了浏览器和服务器之间的全双工通信问题。在 WebSocket 出现之前，浏览器如果需要从服务器及时获得更新，则需要不停的对服务器主动发起请求，也就是 Web 中常用的`poll`技术。这样的操作非常低效，这是因为每发起一次新的 HTTP 请求，就需要单独开启一个新的 TCP 链接，同时 HTTP 协议本身也是一种开销非常大的协议。为了解决这些问题，所以出现了 WebSocket 协议。WebSocket 使得浏览器和服务器之间能通过一个持久的 TCP 链接就能完成数据的双向通信。关于 WebSocket 的 RFC 提案，可以参看`RFC6455`。

WebSocket 和 HTTP 协议一般情况下都工作在浏览器中，但 WebSocket 是一种完全不同于 HTTP 的协议。尽管，浏览器需要通过 HTTP 协议的`GET`请求，将 HTTP 协议升级为 WebSocket 协议。升级的过程被称为`握手(handshake)`。当浏览器和服务器成功握手后，则可以开始根据 WebSocket 定义的通信帧格式开始通信了。像其他各种协议一样，WebSocket 协议的通信帧也分为控制数据帧和普通数据帧，前者用于控制 WebSocket 链接状态，后者用于承载数据。下面我们将一一分析 WebSocket 协议的握手过程以及通信帧格式。

### websocket协议的握手过程

握手的过程也就是将 HTTP 协议升级为 WebSocket 协议的过程。前面我们说过，握手开始首先由浏览器端发送一个`GET`请求开发，该请求的 HTTP 头部信息如下：

```yml
        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13
```

当服务器端，成功验证了以上信息后，则会返回一个形如以下信息的响应:

```yml
        HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
        Sec-WebSocket-Protocol: chat
```

可以看到，浏览器发送的 HTTP 请求中，增加了一些新的字段，其作用如下所示：

- `Upgrade`: 规定必需的字段，其值必需为 `websocket`, 如果不是则握手失败；
- `Connection`: 规定必需的字段，值必需为 `Upgrade`, 如果不是则握手失败；
- `Sec-WebSocket-Key`: 必需字段，一个随机的字符串；
- `Sec-WebSocket-Protocol`: 可选字段，可以用于标识应用层的协议；
- `Sec-WebSocket-Version`: 必需字段，代表了 WebSocket 协议版本，值必需是 `13`, 否则握手失败；

返回的响应中，如果握手成功会返回状态码为 `101` 的 HTTP 响应。同时其他字段说明如下：

- `Upgrade`: 规定必需的字段，其值必需为 `websocket`, 如果不是则握手失败；
- `Connection`: 规定必需的字段，值必需为 Upgrade, 如果不是则握手失败；
- `Sec-WebSocket-Accept`: 规定必需的字段，该字段的值是通过固定字符串`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`加上请求中`Sec-WebSocket-Key`字段的值，然后再对其结果通过 SHA1 哈希算法求出的结果。
- `Sec-WebSocket-Protocol`: 对应于请求中的 `Sec-WebSocket-Protocol` 字段；

当浏览器和服务器端成功握手后，就可以传送数据了，传送数据是按照 WebSocket 协议的数据格式生成的。







# api-server代码理解

+ api-server代码

[ChinaRailwayPlatform / api-server · GitLab](http://10.11.12.216/chinarailwayplatform/api-server)

[api-server: api-server 是”瑶光智能视觉开源平台“对外暴露平台接口的统一入口 (gitee.com)](https://gitee.com/NonCooperative_platform/api-server)

分为ReId_platform，NonCooperative_platform，HealthMonitoring_platform三个平台，`pkg`为跟后端交互，`route`为跟前端交互代码。

要注意本地的go

## 运行

临时添加环境变量

~~~
	1. export GOROOT=/home/go 
	2. export PATH=$PATH:$GOROOT/bin
~~~

配置go proxy

~~~
go env -w GOPROXY=https://goproxy.cn,direct
~~~



## puzzle

1. `main.go`文件当中的gr和v1是什么意思？

   简写import的包，用于指代

2. `main.go` import导入的`zhejianglab/gin-apiserver/initialize`是绝对路径吗？

   1. [使用go module导入本地包 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/109828249)
   2. `go.mod`文件里面`module zhejianglab/gin-apiserver`
   3. 所以`zhejianglab/gin-apiserver/initialize`表示导入当前路径的`gin-apiserver`文件夹

3. `main.go`的`net/http`为什么有两个，还带个_符号。

   1. [Golang－ import 导入包的几种方式：点，别名与下划线 - ExplorerMan - 博客园 (cnblogs.com)](https://www.cnblogs.com/ExMan/p/11490719.html)
   2. 导入这个包的时候Init就会被执行，前面加下划线表示只调用Init函数
   3. 简要意思就是初始化这个函数的意思吧。

4. 运行报错

~~~
{"level":"fatal","ts":"2021-12-08T02:42:52Z","msg":"gRPC net.Listen err ","reason":"listen tcp :6061: bind: address already in use"}
~~~

 因为api-server是运行在docker里面。

+ 查看端口进程命令
  + `netstat -anpl|grep 端口号`

+ 打开docker的api-server

  + 执行build/build.sh的命令

  + ~~~
    docker build -t apiserver:latest -f Dockerfile ./
    docker create --name apiserver -p 6060:6060 -p 6061:6061 -p 7070:7070 -v /data/:/data/ --net=host --restart=always  apiserver:latest
    docker start apiserver
    ~~~

+ 关闭docker的api-server
  + `docker stop api-server`

+ 查看当前docker使用队列`docker ps`

5. 运行报错

~~~
docker: Error response from daemon: Conflict. The container name "/xx" is already in use
~~~

原因是虽然之前的容器停止了但是没有被删除，需要用`docker rm (containerID)`删除同名容器。

[docker: Error response from daemon: Conflict. The container name "/xx" is already in use - youxin - 博客园 (cnblogs.com)](https://www.cnblogs.com/youxin/p/12993816.html)

### docker使用

+ docker build

使用Dockerfile创建镜像

```
docker build [OPTIONS] PATH | URL | -
```

OPTIONS说明：

- **--build-arg=[] :**设置镜像创建时的变量；
- **--cpu-shares :**设置 cpu 使用权重；
- **--cpu-period :**限制 CPU CFS周期；
- **--cpu-quota :**限制 CPU CFS配额；
- **--cpuset-cpus :**指定使用的CPU id；
- **--cpuset-mems :**指定使用的内存 id；
- **--disable-content-trust :**忽略校验，默认开启；
- **-f :**指定要使用的Dockerfile路径；
- **--force-rm :**设置镜像过程中删除中间容器；
- **--isolation :**使用容器隔离技术；
- **--label=[] :**设置镜像使用的元数据；
- **-m :**设置内存最大值；
- **--memory-swap :**设置Swap的最大值为内存+swap，"-1"表示不限swap；
- **--no-cache :**创建镜像的过程不使用缓存；
- **--pull :**尝试去更新镜像的新版本；
- **--quiet, -q :**安静模式，成功后只输出镜像 ID；
- **--rm :**设置镜像成功后删除中间容器；
- **--shm-size :**设置/dev/shm的大小，默认值是64M；
- **--ulimit :**Ulimit配置。
- **--squash :**将 Dockerfile 中所有的操作压缩为一层。
- **--tag, -t:** 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
- **--network:** 默认 default。在构建期间设置RUN指令的网络模式

`docker build -t apiserver:latest -f Dockerfile ./`

使用Dockerfile创建一个名称为apiserver，标签为latest的镜像。



+ docker create

用于创建一个新的容器，载入镜像

~~~
docker create --name apiserver -p 6060:6060 -p 6061:6061 -p 7070:7070 -v /data/:/data/ --net=host --restart=always  apiserver:latest
~~~

Usage:`docker create [OPTIONS] IMAGE [COMMAND] [ARG...]`

```csharp
-p, --publish list                   Publish a container's port(s) to the host
```

```csharp
-v, --volume list                    Bind mount a volume
```

我们在使用docker run创建Docker容器时，可以用`--network`标志 选项指定容器的网络模式，Docker有以下4种网络模式：

host模式：使用 --net=host 指定。

none模式：使用 --net=none 指定。

bridge模式：使用 --net=bridge 指定，默认设置。

container模式：使用 --net=container:NAME_or_ID 指定。



+ docker start

启动镜像

+ docker stop

关闭镜像



## misunderstand

### sync.WaitGroup

[Golang等待组sync.WaitGroup的用法 - 起风了 (dyxmq.cn)](https://www.dyxmq.cn/program/code/golang/waitgroup-in-golang.html)

Go语言中除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务

在 sync.WaitGroup（等待组）类型中，每个 sync.WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。

在`WaitGroup` 对象实现中，内部有一个计数器，最初从0开始，它有三个方法：

- `Add()`：计数器加一
- `Done()`：计数器减一
- `Wait()`：等待计数器清零

执行`Wait`方法的函数在等待组内部计数器不为0的时候回阻塞，一旦计数器为0了，程序就会继续往下执行。

### gin.Default()

~~~
r := gin.Default()
r.GET("/ping", func(c *gin.Context) {
    c.JSON(200, gin.H{
        "message": "pong",
    })
})
r.Run() // 监听并在 0.0.0.0:8080 上启动服务
~~~

`r := gin.Default()`我们需要先构建[路由对象](https://www.zhihu.com/search?q=路由对象&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A90122089})，也就是 `gin.Engine` 路由对象，之后在路由对象上注册请求路径对应的处理器（包括中间件），最后通过路由对象的 `router.Run` 方法启动监听。

### JSON

~~~
package main

import "github.com/gin-gonic/gin"

func main() {
    r := gin.Default()
    r.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "Blog":"www.flysnow.org",
            "wechat":"flysnow_org",
        })
    })
    r.Run(":8080")
}
~~~

Gin允许我们对特定的HTTP方法进行不同的处理，这就为我们实现Restful API提供了方便，比如这个示例中，如果我们通过POST方法请求`http://localhost:8080/`会提示404的。

以上返回也很简单，`c.JSON`方法就是返回一个JSON格式的字符串，它的方法签名如下：

```
func (c *Context) JSON(code int, obj interface{})
```

`code`便是返回的`HTTP Status Code`,`obj`是内容，我这里使用的`gin.H`其实是一个`map[string]interface{}`,声明为`H`类型，便于操作。

```
type H map[string]interface{}
```

最后，我们就可以通过`r.Run(":8080")`启动一个HTTP服务了，端口是`8080`，所以我们访问`http://localhost:8080/`看到返回的JSON内容。

- [gin.Context](https://gowalker.org/github.com/gin-gonic/gin#Context)：`Context`是`gin`中的上下文，它允许我们在中间件之间传递变量、管理流、验证 JSON 请求、响应 JSON 请求等，在`gin`中包含大量`Context`的方法，例如我们常用的`DefaultQuery`、`Query`、`DefaultPostForm`、`PostForm`等等

### APIGroup := Router.Group("")：分组路由

[Go Web轻量级框架Gin学习系列：路由分组_weixin_34007879的博客-CSDN博客](https://blog.csdn.net/weixin_34007879/article/details/91394486)

[Go Web轻量级框架Gin学习系列：中间件使用详解 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903833164857358)

一个分组路由下所有操作是平行的，

### http.ListenAndServe()

http.ListenAndServe用到的所有依赖都在Go源码中的**/src/pkg/net/http/server.go**文件中

```go
func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == "" {
        addr = ":http"
    }
    ln, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
```

开始监听服务，监听 TCP 网络地址，Addr 和调用应用程序处理连接上的请求。

我们在源码中看到`Addr`是调用我们在`&http.Server`中设置的参数，因此我们在设置时要用`&`，我们要改变参数的值，因为我们`ListenAndServe`和其他一些方法需要用到`&http.Server`中的参数，他们是相互影响的。

## code framework

~~~
api-server
|---InitRouter
|---|--—initialize.InitRouter()初始化路由
|---|--—port来源为conf.ini文件，使用了go-ini库

|---grpc StartReIdGrpc
|---|---
|---websocket RunWebSocket
|---http.ListenAndServe
~~~



### folder framework

~~~~  
api-server
|---build	构造说明
|---conf	配置文件
|---docs	swagger接口说明
|---initialize
	router.go	注册路由，调用routers文件
|---model
|---|---request	定义所有消息的结构体和json解析格式
|---定义同名函数针对数据库的增删改查
|---pkg
|---|---grpc
		reid_service.go
		server.go
|---|---jwt
		jwt.go
|---|---net
		response.go	好像没用？
|---|---setting
		setting.go	调用go-ini库，解析配置文件，获取参数
|---|---websocket
		client.go
		websockets.go
|---proto
|---routers
	init_routers.go	分组路由，注册调用函数
|---|---api/v1	定义不同数据进入后的交互
		

~~~~

#### gorm.Model

`/model`和`/model/request`对于同一个结构体的定义有一点点区别，多了个`gorm.Model`

`gorm.Model` 是一个包含一些基本字段的结构体, 包含的字段有 `ID`，`CreatedAt`， `UpdatedAt`， `DeletedAt`。



## code analyze

### init_routers

针对不同类型任务进行路由分组，针对不同请求使用函数进行处理，

~~~
func InitAlarmRouter(router *gin.RouterGroup) {
	apiV1 := router.Group("/api/v1/alarm")
	{
		apiV1.POST("/new", v1.AddNewAlarm)
		apiV1.GET("", v1.GetAlarmWithType)
		apiV1.PUT("/:id", v1.UpdateAlarm)
		apiV1.DELETE("/:id", v1.DeleteAlarm)
	}
}
~~~

根据不同的任务分组，`routers/api/v1`目录下的函数进行处理。比如v1下面的`AddNewAlarm`，先调用`ShouldBindJSON`函数进行解析，再调用model里面的同名函数将数据添加到数据库当中，



### gin.Context

#### ShouldBindJSON

**只会返回错误信息，不会往header里面写400的错误状态码**

ShouldBindJSON方法是最常用解析JSON数据的方法之一，但在重复调用的情况下会出现EOF的报错，这个原因出在ShouldBindJSON在调用过一次之后context.request.body.sawEOF的值是false导致，所以如果要多次绑定多个变量，需要使用ShouldBindBodyWith。



### HTTP状态码

`http.StatusInternalServerError`=500

[HTTP常用的14种状态码_Sara2018的博客-CSDN博客_常用状态码](https://blog.csdn.net/qq_35689573/article/details/82120851)

## go调用的github库

### go-ini

+ 配置文件解析

[go-ini/ini: 超赞的 Go 语言 INI 文件操作 (unknwon.io)](https://ini.unknwon.io/)

[Go 每日一库之 go-ini - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102972063)

~~~
// 由 Must 开头的方法名允许接收一个相同类型的参数来作为默认值，
// 当键不存在或者转换失败时，则会直接返回该默认值。
// 但是，MustString 方法必须传递一个默认值。
~~~

+ 创建配置文件

### Go-Guardian

[用Go-Guardian写一个Golang的可扩展的身份认证 - InfoQ 写作平台](https://xie.infoq.cn/article/b334aae95fdc0d7d8fa7ba4f7)

### prometheus

- [prometheus client_golang 简单使用 | 纸盒人 (hulining.github.io)](https://hulining.github.io/2020/07/01/prometheus-client_golang-Introduction/)
- [浅谈prometheus(普罗米修斯) client golang_Skying_的博客-CSDN博客_golang 普罗米修斯](https://blog.csdn.net/Skying_/article/details/104044745)

### gin



### gorm

orm是go语言中实现数据库访问的**ORM（对象关系映射）库**。

+ 建表

建表一般采用 数据模型同步的方式，先创建一个 model

```javascript
  type AccountInfo struct {
    gorm.Model
    Name     string `gorm:"not null;unique"`
    Password string `gorm:"not null;"`
    Status   uint   `gorm:"default:0"`
  }
```

然后再下面这样，这时数据表会自动建立

```javascript
    // 自动迁移模式
db.AutoMigrate(&AccountInfo{})
```

+ where查询表单

[golang gorm增删改查db.Model db.Where db.Table_疯狂的鸭血-CSDN博客_gorm model table 区别](https://blog.csdn.net/weixin_45604257/article/details/105139862)



# Golang的web框架（Gin）

[#Golang Gin 实战 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1362784031968149504&__biz=MzI3MjU4Njk3Ng==#wechat_redirect)



## go module和GOPATH

要使用Gin非常简单，它和其他第三方 Golang 库一样。如果你是基于`GOPATH`开发的，你需要先使用`go get -u github.com/gin-gonic/gin` 下载gin，然后`import`导入即可。

如果你是用Go Module这种方式，使用`import`直接导入使用，然后你在`go run`运行的时候，会自动的下载`gin`包编译使用。当然你也可以通过`go mod tidy`来下载依赖的模块。



## RESTful API规范

实我们应该可以发现，我们开发的一个个Web应用服务或者程序，其实就是对服务器的资源的CRUD（创建、检索、更新和删除），所以 RESTful API 的规范建议我们使用特定的HTTP方法来对服务器上的资源进行操作。

在 RESTful API 中，使用的主要是以下五种HTTP方法：

1. GET，表示读取服务器上的资源
2. POST，表示在服务器上创建资源
3. PUT,表示更新或者替换服务器上的资源
4. DELETE，表示删除服务器上的资源
5. PATCH，表示更新/修改资源的一部分

各个 HTTP 方法的作用说明如下：

- GET——命令服务器返回指定的资源。
- HEAD——与 GET 方法的作用类似，唯一的不同在于这个方法不要求服务器返回报文的主体。这个方法通常用于在不获取报文主体的情况下，取得响应的首部。
- POST——命令服务器将报文主体中的数据传递给 URI 指定的资源，至于服务器具体会对这些数据执行什么动作则取决于服务器本身。
- PUT——命令服务器将报文主体中的数据设置为 URI 指定的资源。如果 URI 指定的位置上已经有数据存在，那么使用报文主体中的数据去代替已有的数据。如果资源尚未存在，那么在 URI 指定的位置上新创建一个资源。
- DELETE——命令服务器删除 URI 指定的资源。
- TRACE——命令服务器返回请求本身。通过这个方法，客户端可以知道介于它和服务器之间的其他服务器是如何处理请求的。
- OPTIONS——命令服务器返回它支持的 HTTP 方法列表。
- CONNECT——命令服务器与客户端建立一个网络连接。这个方法通常用于设置 SSL 隧道以开启 HTTPS 功能。
- PATCH——命令服务器使用报文主体中的数据对 URI 指定的资源进行修改。

这里我通过一些URL示例来更好的说明这些HTTP方法的使用。

```
HTTP GET https://www.flysnow.org/users
HTTP GET https://www.flysnow.org/users/123
```

以上是两个`GET`方法的示例，第一个表示获取所有用户的信息；第二个表示获取`id`为`123`用户的信息。

```
HTTP POST https://www.flysnow.org/users
```

这表示创建一个用户，会通过`POST`给服务器提供创建这个用户所需的全部信息。注意这里`users`是个复数

```
HTTP PUT https://www.flysnow.org/users/123
```

这表示要更新/替换`id`为`123`的这个用户，在更新的时候，会通过`PUT`提供更新这个用户需要的全部用户信息。这里`PUT`和`POST`不太一样的是 ，从URL看，`PUT`操作的是单个资源，比如这里`id`为`123`的这个用户。

```
HTTP DELETE https://www.flysnow.org/users/123
```

删除非常简单，也是操作单个资源，这里是删除`id`为`123`的这个用户。

```
HTTP PATCH https://www.flysnow.org/users/123
```

`PATCH`也更新资源，它和`PUT`不一样的是，它只能更新这个资源的部分信息，而不是全部(这种也叫替换)，是部分更新。所以我们无需提供全部用户信息给服务器，需要更新哪些就提供哪些。

RESTful API 规范关于这部分HTTP方法的定义是非常好的，这让我们可以在编写API的时候更加规范，可读性强，便于协作。RESTful API规范这么好，对于我们强大的Golang Gin这个框架来说，自然不会忘记，Golang Gin为我们提供了一套非常简洁的接口，让我们可以很容易的实现RESTful API的规范。





# wireshark



+ 根据ip目标地址筛选
  +  `ip.dst==10.11.44.49`



# 跟煎鱼学go

[《跟煎鱼学 Go》 (eddycjy.com)](https://eddycjy.com/go-categories/)

## HTTP部分

+ 实现

![image-20211209153152903](E:\Document\Typora\img\image-20211209153152903.png)

![image-20211209153202735](E:\Document\Typora\img\image-20211209153202735.png)

+ 增加标签模块的实现
  + get

![image-20211210111143455](E:\Document\Typora\img\image-20211210111143455.png)

![image-20211210111153134](E:\Document\Typora\img\image-20211210111153134.png)

+ 
  + POST

![image-20211210111329506](E:\Document\Typora\img\image-20211210111329506.png)

![image-20211210111429262](E:\Document\Typora\img\image-20211210111429262.png)

+ make(map[string]interface{})
+ 用`Postman`用 POST 访问`http://127.0.0.1:8000/api/v1/tags?name=1&state=1&created_by=test`，查看`code`是否返回`200`及`blog_tag`表中是否有值，有值则正确。

